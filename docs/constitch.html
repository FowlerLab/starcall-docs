<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><title>Python: package constitch</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head><body bgcolor="#f0f0f8">

<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="heading">
<tr bgcolor="#7799ee">
<td valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial">&nbsp;<br><big><big><strong>constitch</strong></big></big></font></td
><td align=right valign=bottom
><font color="#ffffff" face="helvetica, arial"><a href=".">index</a><br><a href="file:/home/nicho/starcall-docs/constitch/__init__.py">/home/nicho/starcall-docs/constitch/__init__.py</a></font></td></tr></table>
    <p><tt>ConStitch:&nbsp;A&nbsp;stitching&nbsp;library&nbsp;that&nbsp;solves&nbsp;the&nbsp;global&nbsp;alignment&nbsp;of&nbsp;images&nbsp;using<br>
a&nbsp;graph&nbsp;of&nbsp;pairwise&nbsp;constraints&nbsp;between&nbsp;images.<br>
&nbsp;<br>
Stitching&nbsp;is&nbsp;a&nbsp;vital&nbsp;step&nbsp;in&nbsp;the&nbsp;fisseq&nbsp;pipeline,&nbsp;as&nbsp;it&nbsp;is&nbsp;in&nbsp;any&nbsp;microscopy<br>
data&nbsp;pipeline,&nbsp;however&nbsp;fisseq&nbsp;has&nbsp;some&nbsp;requirements&nbsp;that&nbsp;make&nbsp;stitching&nbsp;even<br>
more&nbsp;important&nbsp;than&nbsp;in&nbsp;other&nbsp;experimental&nbsp;procedures.&nbsp;This&nbsp;is&nbsp;mainly&nbsp;because<br>
the&nbsp;features&nbsp;we&nbsp;need&nbsp;to&nbsp;detect&nbsp;in&nbsp;cells&nbsp;are&nbsp;quite&nbsp;small,&nbsp;and&nbsp;they&nbsp;need&nbsp;to&nbsp;line<br>
up&nbsp;with&nbsp;each&nbsp;other&nbsp;between&nbsp;cycles&nbsp;in&nbsp;order&nbsp;to&nbsp;detect&nbsp;and&nbsp;read&nbsp;them.&nbsp;To<br>
accomplish&nbsp;this,&nbsp;the&nbsp;stitching&nbsp;package&nbsp;is&nbsp;basically&nbsp;a&nbsp;full&nbsp;stitching&nbsp;library,<br>
capable&nbsp;of&nbsp;stitching&nbsp;any&nbsp;group&nbsp;of&nbsp;images&nbsp;into&nbsp;one&nbsp;contiguous&nbsp;image&nbsp;or<br>
stack&nbsp;of&nbsp;images.<br>
&nbsp;<br>
This&nbsp;stitching&nbsp;library&nbsp;is&nbsp;based&nbsp;on&nbsp;building&nbsp;up&nbsp;a&nbsp;collection&nbsp;of&nbsp;pairwise<br>
offsets&nbsp;between&nbsp;images,&nbsp;represented&nbsp;by&nbsp;the&nbsp;<a href="#Constraint">Constraint</a>&nbsp;class.&nbsp;Using<br>
different&nbsp;algorithms&nbsp;these&nbsp;constraints&nbsp;can&nbsp;be&nbsp;calculated&nbsp;between&nbsp;all<br>
overlapping&nbsp;images,&nbsp;then&nbsp;filtered&nbsp;and&nbsp;processed&nbsp;to&nbsp;improve&nbsp;the&nbsp;accuracy.<br>
Finally,&nbsp;we&nbsp;can&nbsp;consider&nbsp;all&nbsp;constraints&nbsp;and&nbsp;globally&nbsp;solve&nbsp;the&nbsp;positions<br>
of&nbsp;all&nbsp;the&nbsp;images.<br>
&nbsp;<br>
The&nbsp;library&nbsp;is&nbsp;meant&nbsp;to&nbsp;be&nbsp;simple&nbsp;to&nbsp;use&nbsp;for&nbsp;simple&nbsp;use&nbsp;cases,&nbsp;but&nbsp;allow&nbsp;for&nbsp;customization<br>
and&nbsp;fine&nbsp;tuning&nbsp;when&nbsp;you&nbsp;need&nbsp;more&nbsp;control.&nbsp;The&nbsp;whole&nbsp;stitching&nbsp;process&nbsp;is&nbsp;contained&nbsp;in&nbsp;the<br>
<a href="#CompositeImage">CompositeImage</a>&nbsp;class,&nbsp;and&nbsp;the&nbsp;simplest&nbsp;working&nbsp;example&nbsp;is&nbsp;shown&nbsp;below,<br>
it&nbsp;stitches&nbsp;together&nbsp;the&nbsp;provided&nbsp;images&nbsp;and&nbsp;creates&nbsp;a&nbsp;full&nbsp;composite&nbsp;image&nbsp;of&nbsp;them&nbsp;combined<br>
together:<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;composite&nbsp;=&nbsp;constitch.<a href="#CompositeImage">CompositeImage</a>(images,&nbsp;positions)<br>
&nbsp;&nbsp;&nbsp;&nbsp;constrants&nbsp;=&nbsp;composite.constraints(touching=True).calculate().filter(min_score=0.5)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;composite.setpositions(constraints.solve())<br>
&nbsp;&nbsp;&nbsp;&nbsp;full_image&nbsp;=&nbsp;composite.stitch()<br>
&nbsp;<br>
This&nbsp;will&nbsp;work&nbsp;with&nbsp;most&nbsp;smaller&nbsp;stitching&nbsp;problems,&nbsp;where&nbsp;images&nbsp;is&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;images<br>
in&nbsp;the&nbsp;form&nbsp;of&nbsp;numpy&nbsp;arrays,&nbsp;and&nbsp;positions&nbsp;is&nbsp;a&nbsp;numpy&nbsp;array&nbsp;of&nbsp;initial&nbsp;positions&nbsp;for&nbsp;each<br>
image.&nbsp;A&nbsp;more&nbsp;in&nbsp;depth&nbsp;run&nbsp;through&nbsp;of&nbsp;the&nbsp;stitching&nbsp;process&nbsp;can&nbsp;be&nbsp;found&nbsp;in&nbsp;the<br>
documentation&nbsp;of&nbsp;the&nbsp;<a href="#CompositeImage">CompositeImage</a>.</tt></p>
<p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#aa55cc">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Package Contents</strong></big></font></td></tr>
    
<tr><td bgcolor="#aa55cc"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><table width="100%" summary="list"><tr><td width="25%" valign=top><a href="constitch.alignment.html">alignment</a><br>
<a href="constitch.composite.html">composite</a><br>
<a href="constitch.constraints.html">constraints</a><br>
</td><td width="25%" valign=top><a href="constitch.evaluation.html">evaluation</a><br>
<a href="constitch.merging.html">merging</a><br>
<a href="constitch.solving.html">solving</a><br>
</td><td width="25%" valign=top><a href="constitch.stage_model.html">stage_model</a><br>
<a href="constitch.stitching.html">stitching</a><br>
<a href="constitch.utils.html">utils</a><br>
</td><td width="25%" valign=top></td></tr></table></td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ee77aa">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Classes</strong></big></font></td></tr>
    
<tr><td bgcolor="#ee77aa"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><dl>
<dt><font face="helvetica, arial"><a href="builtins.html#object">builtins.object</a>
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="constitch.alignment.html#Aligner">constitch.alignment.Aligner</a>
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="constitch.alignment.html#FFTAligner">constitch.alignment.FFTAligner</a>
</font></dt><dt><font face="helvetica, arial"><a href="constitch.alignment.html#FeatureAligner">constitch.alignment.FeatureAligner</a>
</font></dt><dt><font face="helvetica, arial"><a href="constitch.alignment.html#PCCAligner">constitch.alignment.PCCAligner</a>
</font></dt></dl>
</dd>
<dt><font face="helvetica, arial"><a href="constitch.composite.html#BBox">constitch.composite.BBox</a>
</font></dt><dt><font face="helvetica, arial"><a href="constitch.composite.html#BBoxList">constitch.composite.BBoxList</a>
</font></dt><dt><font face="helvetica, arial"><a href="constitch.composite.html#CompositeImage">constitch.composite.CompositeImage</a>
</font></dt><dt><font face="helvetica, arial"><a href="constitch.constraints.html#Constraint">constitch.constraints.Constraint</a>
</font></dt><dt><font face="helvetica, arial"><a href="constitch.constraints.html#ConstraintFilter">constitch.constraints.ConstraintFilter</a>
</font></dt><dt><font face="helvetica, arial"><a href="constitch.constraints.html#ConstraintSet">constitch.constraints.ConstraintSet</a>
</font></dt><dt><font face="helvetica, arial"><a href="constitch.merging.html#Merger">constitch.merging.Merger</a>
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="constitch.merging.html#EfficientMeanMerger">constitch.merging.EfficientMeanMerger</a>
</font></dt><dt><font face="helvetica, arial"><a href="constitch.merging.html#EfficientNearestMerger">constitch.merging.EfficientNearestMerger</a>
</font></dt><dt><font face="helvetica, arial"><a href="constitch.merging.html#LastMerger">constitch.merging.LastMerger</a>
</font></dt><dt><font face="helvetica, arial"><a href="constitch.merging.html#MeanMerger">constitch.merging.MeanMerger</a>
</font></dt><dt><font face="helvetica, arial"><a href="constitch.merging.html#NearestMerger">constitch.merging.NearestMerger</a>
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="constitch.merging.html#MaskMerger">constitch.merging.MaskMerger</a>
</font></dt></dl>
</dd>
</dl>
</dd>
<dt><font face="helvetica, arial"><a href="constitch.solving.html#Solver">constitch.solving.Solver</a>
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="constitch.solving.html#LinearSolver">constitch.solving.LinearSolver</a>
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="constitch.solving.html#LPSolver">constitch.solving.LPSolver</a>
</font></dt><dt><font face="helvetica, arial"><a href="constitch.solving.html#MAESolver">constitch.solving.MAESolver</a>
</font></dt><dt><font face="helvetica, arial"><a href="constitch.solving.html#OptimalSolver">constitch.solving.OptimalSolver</a>
</font></dt></dl>
</dd>
<dt><font face="helvetica, arial"><a href="constitch.solving.html#OutlierSolver">constitch.solving.OutlierSolver</a>
</font></dt><dt><font face="helvetica, arial"><a href="constitch.solving.html#SpanningTreeSolver">constitch.solving.SpanningTreeSolver</a>
</font></dt></dl>
</dd>
</dl>
</dd>
<dt><font face="helvetica, arial"><a href="constitch.stage_model.html#ConversionStageModel">constitch.stage_model.ConversionStageModel</a>(<a href="sklearn.base.html#BaseEstimator">sklearn.base.BaseEstimator</a>)
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="constitch.stage_model.html#GlobalStageModel">constitch.stage_model.GlobalStageModel</a>
</font></dt><dt><font face="helvetica, arial"><a href="constitch.stage_model.html#SimpleOffsetModel">constitch.stage_model.SimpleOffsetModel</a>
</font></dt></dl>
</dd>
</dl>
 <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Aligner">class <strong>Aligner</strong></a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Abstract&nbsp;class&nbsp;that&nbsp;defines&nbsp;an&nbsp;algorithm&nbsp;for&nbsp;aligning&nbsp;two&nbsp;images&nbsp;onto&nbsp;each&nbsp;other.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="Aligner-align"><strong>align</strong></a>(self, constraint, precalc1=None, precalc2=None)</dt><dd><tt>Performs&nbsp;the&nbsp;alignment&nbsp;of&nbsp;two&nbsp;images,&nbsp;finding&nbsp;the&nbsp;pixel&nbsp;offset&nbsp;that&nbsp;best&nbsp;aligns&nbsp;the<br>
two&nbsp;images.&nbsp;The&nbsp;offset&nbsp;should&nbsp;be&nbsp;from&nbsp;image1&nbsp;to&nbsp;image2.&nbsp;The&nbsp;return&nbsp;value&nbsp;should&nbsp;be&nbsp;a&nbsp;<a href="#Constraint">Constraint</a><br>
<a href="builtins.html#object">object</a>,&nbsp;with&nbsp;at&nbsp;least&nbsp;the&nbsp;dx,&nbsp;dy&nbsp;fields&nbsp;filled&nbsp;in&nbsp;to&nbsp;represent&nbsp;the&nbsp;offset&nbsp;of&nbsp;image2&nbsp;needed<br>
to&nbsp;align&nbsp;the&nbsp;two&nbsp;images.&nbsp;If&nbsp;the&nbsp;function&nbsp;finds&nbsp;the&nbsp;images&nbsp;don't&nbsp;overlap,&nbsp;None&nbsp;should&nbsp;be&nbsp;returned.<br>
If&nbsp;a&nbsp;constraint&nbsp;is&nbsp;specified,&nbsp;this&nbsp;method&nbsp;should&nbsp;only&nbsp;return&nbsp;a&nbsp;constraint&nbsp;that&nbsp;fits&nbsp;within&nbsp;the&nbsp;error<br>
of&nbsp;given&nbsp;constraint,&nbsp;meaning&nbsp;within&nbsp;constraint.error&nbsp;pixels&nbsp;from&nbsp;the&nbsp;(constraint.dx,&nbsp;constraint.dy)<br>
offset.</tt></dd></dl>

<dl><dt><a name="Aligner-precalculate"><strong>precalculate</strong></a>(self, image, box)</dt><dd><tt>Performs&nbsp;an&nbsp;arbitrary&nbsp;precalculation&nbsp;step&nbsp;specific&nbsp;to&nbsp;the&nbsp;alignment&nbsp;algorithm.<br>
This&nbsp;would&nbsp;be&nbsp;a&nbsp;step&nbsp;in&nbsp;the&nbsp;algorithm&nbsp;that&nbsp;only&nbsp;has&nbsp;to&nbsp;be&nbsp;run&nbsp;once&nbsp;per&nbsp;image,<br>
and&nbsp;can&nbsp;be&nbsp;cached&nbsp;for&nbsp;each&nbsp;calculation&nbsp;done&nbsp;with&nbsp;the&nbsp;same&nbsp;image.&nbsp;The&nbsp;result&nbsp;of<br>
this&nbsp;function&nbsp;will&nbsp;be&nbsp;passed&nbsp;to&nbsp;the&nbsp;align&nbsp;function&nbsp;as&nbsp;the&nbsp;precalc1&nbsp;or&nbsp;precalc2&nbsp;argument</tt></dd></dl>

<dl><dt><a name="Aligner-precalculate_if_needed"><strong>precalculate_if_needed</strong></a>(self, constraint, precalc1, precalc2)</dt></dl>

<dl><dt><a name="Aligner-resize_if_needed"><strong>resize_if_needed</strong></a>(self, image, box=None, downscale_factor=None, padding=None)</dt><dd><tt>#&nbsp;Helper&nbsp;functions&nbsp;for&nbsp;subclasses:</tt></dd></dl>

<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="BBox">class <strong>BBox</strong></a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#BBox">BBox</a>(position=None,&nbsp;size=None,&nbsp;point1=None,&nbsp;point2=None)<br>
&nbsp;<br>
Represents&nbsp;the&nbsp;bounding&nbsp;box&nbsp;of&nbsp;an&nbsp;image&nbsp;in&nbsp;a&nbsp;<a href="#CompositeImage">CompositeImage</a>.&nbsp;Contains&nbsp;two<br>
representations&nbsp;of&nbsp;the&nbsp;box,&nbsp;as&nbsp;a&nbsp;position&nbsp;and&nbsp;a&nbsp;size&nbsp;and&nbsp;as&nbsp;two&nbsp;points&nbsp;point1&nbsp;and&nbsp;point2<br>
which&nbsp;define&nbsp;the&nbsp;bounding&nbsp;box.&nbsp;Both&nbsp;representations&nbsp;can&nbsp;be&nbsp;retrieved&nbsp;from&nbsp;and&nbsp;assigned&nbsp;to<br>
at&nbsp;<a href="#BBox">BBox</a>.position,&nbsp;<a href="#BBox">BBox</a>.size,&nbsp;<a href="#BBox">BBox</a>.point1,&nbsp;<a href="#BBox">BBox</a>.point2,&nbsp;and&nbsp;a&nbsp;<a href="#BBox">BBox</a>&nbsp;can&nbsp;be&nbsp;constructed<br>
from&nbsp;either.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="BBox-__init__"><strong>__init__</strong></a>(self, position=None, size=None, point1=None, point2=None)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="BBox-__repr__"><strong>__repr__</strong></a>(self)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="BBox-__str__"><strong>__str__</strong></a>(self)</dt><dd><tt>Return&nbsp;str(self).</tt></dd></dl>

<dl><dt><a name="BBox-as2d"><strong>as2d</strong></a>(self)</dt><dd><tt>Creates&nbsp;a&nbsp;copy&nbsp;of&nbsp;this&nbsp;box&nbsp;that&nbsp;only&nbsp;has&nbsp;two&nbsp;dimensions,<br>
dropping&nbsp;extra&nbsp;values.</tt></dd></dl>

<dl><dt><a name="BBox-collides"><strong>collides</strong></a>(self, otherbox)</dt><dd><tt>Whether&nbsp;this&nbsp;box&nbsp;collides&nbsp;with&nbsp;the&nbsp;other&nbsp;box.&nbsp;This&nbsp;is&nbsp;defined&nbsp;as&nbsp;either<br>
overlapping&nbsp;or&nbsp;sharing&nbsp;an&nbsp;edge</tt></dd></dl>

<dl><dt><a name="BBox-contains"><strong>contains</strong></a>(self, otherbox)</dt><dd><tt>Whether&nbsp;this&nbsp;box&nbsp;fully&nbsp;contains&nbsp;the&nbsp;other&nbsp;box,&nbsp;meaning&nbsp;every&nbsp;pixel&nbsp;in&nbsp;the&nbsp;other<br>
box&nbsp;is&nbsp;also&nbsp;contained&nbsp;in&nbsp;this&nbsp;box</tt></dd></dl>

<dl><dt><a name="BBox-copy"><strong>copy</strong></a>(self)</dt></dl>

<dl><dt><a name="BBox-overlaps"><strong>overlaps</strong></a>(self, otherbox)</dt><dd><tt>Whether&nbsp;this&nbsp;box&nbsp;overlaps&nbsp;with&nbsp;the&nbsp;other&nbsp;box.&nbsp;This&nbsp;does&nbsp;not&nbsp;consider<br>
sharing&nbsp;an&nbsp;edge&nbsp;as&nbsp;overlapping,&nbsp;to&nbsp;count&nbsp;as&nbsp;overlapping&nbsp;there&nbsp;must&nbsp;be&nbsp;at&nbsp;least<br>
one&nbsp;pixel&nbsp;that&nbsp;is&nbsp;contained&nbsp;in&nbsp;both&nbsp;images</tt></dd></dl>

<hr>
Readonly properties defined here:<br>
<dl><dt><strong>center</strong></dt>
<dd><tt>The&nbsp;center&nbsp;pixel&nbsp;of&nbsp;the&nbsp;image,&nbsp;rounded&nbsp;to&nbsp;the&nbsp;nearest&nbsp;pixel.&nbsp;Equivalent<br>
to&nbsp;np.round(self.<strong>position</strong>&nbsp;+&nbsp;self.<strong>size</strong>&nbsp;/&nbsp;2)</tt></dd>
</dl>
<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>point1</strong></dt>
<dd><tt>The&nbsp;first&nbsp;position&nbsp;that&nbsp;defines&nbsp;the&nbsp;bounding&nbsp;box&nbsp;of&nbsp;the&nbsp;image.<br>
When&nbsp;retrieved&nbsp;is&nbsp;identical&nbsp;to&nbsp;self.<strong>position</strong>.<br>
Can&nbsp;be&nbsp;assigned&nbsp;to,&nbsp;however&nbsp;this&nbsp;is&nbsp;not&nbsp;the&nbsp;same&nbsp;as&nbsp;assigning&nbsp;to&nbsp;self.<strong>position</strong>.<br>
When&nbsp;assigning&nbsp;self.<strong>point2</strong>&nbsp;is&nbsp;maintained,&nbsp;meaning&nbsp;self.<strong>size</strong>&nbsp;will&nbsp;be&nbsp;changed.<br>
The&nbsp;new&nbsp;size&nbsp;is&nbsp;calculated&nbsp;as&nbsp;self.<strong>position</strong>&nbsp;+&nbsp;self.<strong>size</strong>&nbsp;-&nbsp;value<br>
Because&nbsp;of&nbsp;this&nbsp;difference&nbsp;in&nbsp;assignment&nbsp;behavior&nbsp;it&nbsp;cannot&nbsp;be&nbsp;updated<br>
by&nbsp;indexing,&nbsp;ie&nbsp;box.point1[0]&nbsp;=&nbsp;5&nbsp;will&nbsp;fail.</tt></dd>
</dl>
<dl><dt><strong>point2</strong></dt>
<dd><tt>The&nbsp;second&nbsp;position&nbsp;that&nbsp;defines&nbsp;the&nbsp;bounding&nbsp;box&nbsp;of&nbsp;the&nbsp;image.<br>
Calculated&nbsp;as&nbsp;self.<strong>position</strong>&nbsp;+&nbsp;self.<strong>size</strong>.<br>
This&nbsp;can&nbsp;be&nbsp;assigned&nbsp;to,&nbsp;which&nbsp;will&nbsp;change&nbsp;the&nbsp;size&nbsp;of&nbsp;the&nbsp;image,&nbsp;keeping<br>
self.<strong>point1</strong>&nbsp;and&nbsp;self.<strong>position</strong>&nbsp;the&nbsp;same.&nbsp;The&nbsp;new&nbsp;size&nbsp;is&nbsp;calculated&nbsp;as<br>
value&nbsp;-&nbsp;self.<strong>_position</strong><br>
However&nbsp;it&nbsp;cannot&nbsp;be&nbsp;updated&nbsp;by&nbsp;indexing,&nbsp;ie&nbsp;box.point1[0]&nbsp;=&nbsp;5&nbsp;will&nbsp;fail.</tt></dd>
</dl>
<dl><dt><strong>position</strong></dt>
<dd><tt>The&nbsp;position&nbsp;of&nbsp;the&nbsp;image&nbsp;bounding&nbsp;box,&nbsp;measured&nbsp;from&nbsp;the<br>
origin&nbsp;of&nbsp;the&nbsp;image,&nbsp;ie&nbsp;the&nbsp;(0,&nbsp;0)&nbsp;pixel&nbsp;in&nbsp;the&nbsp;top&nbsp;left&nbsp;of<br>
the&nbsp;image.<br>
Setting&nbsp;the&nbsp;position&nbsp;will&nbsp;move&nbsp;the&nbsp;box&nbsp;to&nbsp;the&nbsp;new&nbsp;position,&nbsp;maintaning<br>
the&nbsp;previous&nbsp;size.&nbsp;Additionally&nbsp;the&nbsp;position&nbsp;can&nbsp;be&nbsp;indexed&nbsp;and&nbsp;modified<br>
in&nbsp;place,&nbsp;such&nbsp;as&nbsp;box.position[0]&nbsp;=&nbsp;5.&nbsp;However&nbsp;care&nbsp;should&nbsp;be&nbsp;made&nbsp;sure&nbsp;to<br>
not&nbsp;make&nbsp;a&nbsp;copy&nbsp;when&nbsp;indexing,&nbsp;as&nbsp;then&nbsp;changes&nbsp;will&nbsp;not&nbsp;take&nbsp;effect.</tt></dd>
</dl>
<dl><dt><strong>size</strong></dt>
<dd><tt>The&nbsp;size&nbsp;of&nbsp;the&nbsp;image&nbsp;bounding&nbsp;box,&nbsp;the&nbsp;(width,&nbsp;height)&nbsp;of&nbsp;the&nbsp;image<br>
This&nbsp;can&nbsp;be&nbsp;assigned&nbsp;to,&nbsp;modifying&nbsp;the&nbsp;box&nbsp;size.&nbsp;As&nbsp;with&nbsp;BBox.position,<br>
it&nbsp;can&nbsp;be&nbsp;indexed&nbsp;and&nbsp;assigned&nbsp;to&nbsp;as&nbsp;well.</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="BBoxList">class <strong>BBoxList</strong></a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#BBoxList">BBoxList</a>(positions=None,&nbsp;sizes=None)<br>
&nbsp;<br>
A&nbsp;list&nbsp;of&nbsp;image&nbsp;bounding&nbsp;boxes,&nbsp;countained&nbsp;in&nbsp;a&nbsp;ConstraintImage.<br>
Supports&nbsp;normal&nbsp;list&nbsp;operations&nbsp;such&nbsp;as&nbsp;indexing,&nbsp;len,&nbsp;index,&nbsp;as&nbsp;well<br>
as&nbsp;bulk&nbsp;operations&nbsp;on&nbsp;all&nbsp;boxes&nbsp;with&nbsp;the&nbsp;numpy&nbsp;array&nbsp;properties<br>
<a href="#BBoxList">BBoxList</a>.positions,&nbsp;<a href="#BBoxList">BBoxList</a>.sizes,&nbsp;and&nbsp;similar<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="BBoxList-__contains__"><strong>__contains__</strong></a>(self, box)</dt></dl>

<dl><dt><a name="BBoxList-__getitem__"><strong>__getitem__</strong></a>(self, index)</dt></dl>

<dl><dt><a name="BBoxList-__init__"><strong>__init__</strong></a>(self, positions=None, sizes=None)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="BBoxList-__iter__"><strong>__iter__</strong></a>(self)</dt></dl>

<dl><dt><a name="BBoxList-__len__"><strong>__len__</strong></a>(self)</dt></dl>

<dl><dt><a name="BBoxList-__repr__"><strong>__repr__</strong></a>(self)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="BBoxList-__str__"><strong>__str__</strong></a>(self)</dt><dd><tt>Return&nbsp;str(self).</tt></dd></dl>

<dl><dt><a name="BBoxList-append"><strong>append</strong></a>(self, box)</dt><dd><tt>Add&nbsp;a&nbsp;new&nbsp;<a href="#BBox">BBox</a>&nbsp;to&nbsp;this&nbsp;list.&nbsp;Typically&nbsp;users&nbsp;should&nbsp;not&nbsp;need&nbsp;to&nbsp;use<br>
this,&nbsp;instead&nbsp;add&nbsp;images&nbsp;through&nbsp;the&nbsp;<a href="#CompositeImage">CompositeImage</a>.add_images&nbsp;and&nbsp;similar<br>
methods</tt></dd></dl>

<dl><dt><a name="BBoxList-copy"><strong>copy</strong></a>(self)</dt></dl>

<dl><dt><a name="BBoxList-index"><strong>index</strong></a>(self, box)</dt></dl>

<dl><dt><a name="BBoxList-resize"><strong>resize</strong></a>(self, n_dims)</dt><dd><tt>Changes&nbsp;the&nbsp;number&nbsp;of&nbsp;dimensions&nbsp;all&nbsp;boxes&nbsp;in&nbsp;the&nbsp;list&nbsp;have.&nbsp;It&nbsp;is&nbsp;enforced<br>
that&nbsp;all&nbsp;boxes&nbsp;in&nbsp;the&nbsp;list&nbsp;have&nbsp;the&nbsp;same&nbsp;number&nbsp;of&nbsp;dimensions.&nbsp;When&nbsp;adding&nbsp;a&nbsp;dimension<br>
it&nbsp;is&nbsp;filled&nbsp;with&nbsp;zeros</tt></dd></dl>

<dl><dt><a name="BBoxList-setpositions"><strong>setpositions</strong></a>(self, positions)</dt><dd><tt>Applies&nbsp;new&nbsp;positions&nbsp;to&nbsp;all&nbsp;boxes<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;positions&nbsp;(sequence&nbsp;of&nbsp;positions,&nbsp;dict&nbsp;of&nbsp;positions,&nbsp;callable):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies&nbsp;a&nbsp;change&nbsp;in&nbsp;positions&nbsp;for&nbsp;boxes,&nbsp;depending&nbsp;on&nbsp;the&nbsp;type:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;a&nbsp;numpy&nbsp;array,&nbsp;the&nbsp;new&nbsp;positions&nbsp;are&nbsp;set&nbsp;as&nbsp;self.<strong>positions</strong>,&nbsp;maintaining&nbsp;sizes&nbsp;of&nbsp;boxes.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;a&nbsp;dict&nbsp;of&nbsp;positions,&nbsp;each&nbsp;entry&nbsp;will&nbsp;be&nbsp;set&nbsp;as&nbsp;the&nbsp;position&nbsp;of&nbsp;the&nbsp;box&nbsp;at&nbsp;the&nbsp;key.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;a&nbsp;callable,&nbsp;it&nbsp;is&nbsp;invoked&nbsp;for&nbsp;each&nbsp;box.&nbsp;If&nbsp;it&nbsp;returns&nbsp;a&nbsp;new&nbsp;position&nbsp;it&nbsp;is&nbsp;applied&nbsp;to&nbsp;the&nbsp;box</tt></dd></dl>

<hr>
Readonly properties defined here:<br>
<dl><dt><strong>centers</strong></dt>
<dd><tt>The&nbsp;center&nbsp;pixel&nbsp;of&nbsp;all&nbsp;image&nbsp;boxes,&nbsp;rounded&nbsp;to&nbsp;the&nbsp;nearest&nbsp;pixel.</tt></dd>
</dl>
<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>points1</strong></dt>
<dd><tt>The&nbsp;lower&nbsp;point&nbsp;of&nbsp;all&nbsp;bounding&nbsp;boxes&nbsp;in&nbsp;the&nbsp;list&nbsp;as&nbsp;a&nbsp;2d&nbsp;array.&nbsp;See&nbsp;BBox.point1.</tt></dd>
</dl>
<dl><dt><strong>points2</strong></dt>
<dd><tt>The&nbsp;higher&nbsp;point&nbsp;of&nbsp;all&nbsp;bounding&nbsp;boxes&nbsp;in&nbsp;the&nbsp;list&nbsp;as&nbsp;a&nbsp;2d&nbsp;array.&nbsp;See&nbsp;BBox.point2.<br>
Setting&nbsp;this&nbsp;will&nbsp;update&nbsp;all&nbsp;sizes,&nbsp;same&nbsp;as&nbsp;assigning&nbsp;to&nbsp;BBox.point2</tt></dd>
</dl>
<dl><dt><strong>positions</strong></dt>
<dd><tt>The&nbsp;positions&nbsp;of&nbsp;all&nbsp;boxes&nbsp;in&nbsp;the&nbsp;list,&nbsp;as&nbsp;a&nbsp;2d&nbsp;numpy&nbsp;array.&nbsp;See&nbsp;BBox.position<br>
for&nbsp;specifics&nbsp;about&nbsp;the&nbsp;positions&nbsp;of&nbsp;the&nbsp;boxes.<br>
Setting&nbsp;this&nbsp;will&nbsp;update&nbsp;all&nbsp;positions,&nbsp;as&nbsp;well&nbsp;as&nbsp;modifying&nbsp;slices,&nbsp;such<br>
as&nbsp;self.<strong>positions</strong>[:,0]&nbsp;+=&nbsp;100&nbsp;would&nbsp;increase&nbsp;all&nbsp;x&nbsp;positions&nbsp;by&nbsp;100.</tt></dd>
</dl>
<dl><dt><strong>sizes</strong></dt>
<dd><tt>The&nbsp;sizes&nbsp;of&nbsp;all&nbsp;boxes&nbsp;in&nbsp;the&nbsp;list&nbsp;as&nbsp;a&nbsp;2d&nbsp;array.&nbsp;See&nbsp;BBox.size.<br>
Setting&nbsp;this&nbsp;will&nbsp;update&nbsp;all&nbsp;sizes,&nbsp;same&nbsp;as&nbsp;assigning&nbsp;to&nbsp;BBox.size</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="CompositeImage">class <strong>CompositeImage</strong></a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#CompositeImage">CompositeImage</a>(images=None,&nbsp;positions=None,&nbsp;boxes=None,&nbsp;scale='pixel',&nbsp;channel_axis=None,&nbsp;grid_size=None,&nbsp;tile_shape=None,&nbsp;overlap=0.1,&nbsp;aligner=None,&nbsp;precalculate=False,&nbsp;debug=True,&nbsp;progress=False,&nbsp;executor=None)<br>
&nbsp;<br>
This&nbsp;class&nbsp;encapsulates&nbsp;the&nbsp;whole&nbsp;stitching&nbsp;process,&nbsp;the&nbsp;smallest&nbsp;example&nbsp;of&nbsp;stitching&nbsp;is<br>
shown&nbsp;below:<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;composite&nbsp;=&nbsp;constitch.<a href="#CompositeImage">CompositeImage</a>()<br>
&nbsp;&nbsp;&nbsp;&nbsp;composite.<a href="#CompositeImage-add_images">add_images</a>(images)<br>
&nbsp;&nbsp;&nbsp;&nbsp;composite.calc_constraints()<br>
&nbsp;&nbsp;&nbsp;&nbsp;composite.filter_constraints()<br>
&nbsp;&nbsp;&nbsp;&nbsp;composite.solve_constraints(filter_outliers=True)<br>
&nbsp;&nbsp;&nbsp;&nbsp;full_image&nbsp;=&nbsp;composite.stitch_images()<br>
&nbsp;<br>
This&nbsp;class&nbsp;is&nbsp;meant&nbsp;to&nbsp;be&nbsp;adaptable&nbsp;to&nbsp;many&nbsp;different&nbsp;stitching&nbsp;use&nbsp;cases,&nbsp;and&nbsp;each&nbsp;step<br>
can&nbsp;be&nbsp;customized&nbsp;and&nbsp;configured.&nbsp;The&nbsp;general&nbsp;steps&nbsp;for&nbsp;the&nbsp;stitching&nbsp;of&nbsp;a&nbsp;group&nbsp;images&nbsp;are&nbsp;as&nbsp;follows:<br>
&nbsp;<br>
&nbsp;<br>
Creating&nbsp;the&nbsp;composite<br>
&nbsp;<br>
To&nbsp;begin&nbsp;we&nbsp;have&nbsp;to&nbsp;instantiate&nbsp;the&nbsp;<a href="#CompositeImage">CompositeImage</a>&nbsp;class.<br>
The&nbsp;full&nbsp;method&nbsp;signature&nbsp;can&nbsp;be&nbsp;found&nbsp;at<br>
<a href="#CompositeImage-__init__">__init__</a>()&nbsp;but&nbsp;some&nbsp;important&nbsp;parameters&nbsp;are&nbsp;described&nbsp;below:<br>
&nbsp;<br>
The&nbsp;executor&nbsp;is&nbsp;what&nbsp;the&nbsp;composite&nbsp;uses&nbsp;to&nbsp;perform&nbsp;intensive&nbsp;computation<br>
tasks,&nbsp;namely&nbsp;calculating&nbsp;the&nbsp;alignment&nbsp;of&nbsp;all&nbsp;the&nbsp;images.&nbsp;If&nbsp;provided<br>
it&nbsp;should&nbsp;be&nbsp;a&nbsp;concurrent.futures.Executor&nbsp;<a href="builtins.html#object">object</a>,&nbsp;for&nbsp;example<br>
concurrent.futures.ThreadPoolExecutor.&nbsp;Importantly,&nbsp;concurrent.futures.ProcessPoolExecutor<br>
does&nbsp;not&nbsp;work&nbsp;very&nbsp;well&nbsp;as&nbsp;the&nbsp;images&nbsp;need&nbsp;to&nbsp;be&nbsp;passed&nbsp;to&nbsp;the&nbsp;executor<br>
and&nbsp;in&nbsp;the&nbsp;case&nbsp;of&nbsp;ProcessPoolExecutor&nbsp;this&nbsp;means&nbsp;they&nbsp;need&nbsp;to&nbsp;be&nbsp;pickled<br>
and&nbsp;unpickled&nbsp;to&nbsp;get&nbsp;to&nbsp;the&nbsp;other&nbsp;process.&nbsp;ThreadPoolExecutor&nbsp;doesn't&nbsp;need<br>
this&nbsp;as&nbsp;the&nbsp;threads&nbsp;can&nbsp;share&nbsp;memory,&nbsp;but&nbsp;it&nbsp;doesn't&nbsp;take&nbsp;full&nbsp;advantage&nbsp;of<br>
multithreading&nbsp;as&nbsp;the&nbsp;python&nbsp;GIL&nbsp;prevents&nbsp;python&nbsp;code&nbsp;from&nbsp;running&nbsp;in&nbsp;parallel.<br>
Luckily&nbsp;most&nbsp;of&nbsp;the&nbsp;intensive&nbsp;computation&nbsp;happens&nbsp;in&nbsp;numpy&nbsp;functions&nbsp;which&nbsp;don't<br>
hold&nbsp;the&nbsp;GIL,&nbsp;so&nbsp;ThreadPoolExecutor&nbsp;is&nbsp;usually&nbsp;the&nbsp;best&nbsp;choice.<br>
&nbsp;<br>
The&nbsp;arguments&nbsp;debug&nbsp;and&nbsp;process&nbsp;define&nbsp;how&nbsp;logging&nbsp;should&nbsp;happen&nbsp;with&nbsp;the&nbsp;composite.<br>
If&nbsp;debug&nbsp;is&nbsp;True&nbsp;logging&nbsp;messages&nbsp;summarizing&nbsp;the&nbsp;results&nbsp;of&nbsp;different&nbsp;operations<br>
will&nbsp;be&nbsp;printed&nbsp;out&nbsp;to&nbsp;stderr.&nbsp;Setting&nbsp;it&nbsp;to&nbsp;False&nbsp;will&nbsp;disable&nbsp;these&nbsp;messages.<br>
If&nbsp;process&nbsp;is&nbsp;True&nbsp;a&nbsp;progress&nbsp;bar&nbsp;will&nbsp;be&nbsp;printed&nbsp;out&nbsp;during&nbsp;long&nbsp;running&nbsp;steps.<br>
The&nbsp;default&nbsp;progress&nbsp;bar&nbsp;is&nbsp;a&nbsp;simple&nbsp;ascii&nbsp;bar&nbsp;that&nbsp;works&nbsp;whether&nbsp;the&nbsp;output&nbsp;is<br>
a&nbsp;tty&nbsp;or&nbsp;a&nbsp;file,&nbsp;but&nbsp;if&nbsp;you&nbsp;want&nbsp;you&nbsp;can&nbsp;pass&nbsp;a&nbsp;replacement&nbsp;in&nbsp;instead&nbsp;of&nbsp;setting<br>
it&nbsp;to&nbsp;True,&nbsp;such&nbsp;as&nbsp;tqdm.<br>
&nbsp;<br>
An&nbsp;example&nbsp;of&nbsp;setting&nbsp;up&nbsp;the&nbsp;composite&nbsp;would&nbsp;be&nbsp;something&nbsp;similar&nbsp;to&nbsp;this:<br>
&nbsp;<br>
import&nbsp;constitch<br>
import&nbsp;concurrent.futures<br>
import&nbsp;tqdm<br>
&nbsp;<br>
with&nbsp;concurrent.futures.ThreadPoolExecutor(max_workers=32)&nbsp;as&nbsp;executor:<br>
&nbsp;&nbsp;&nbsp;&nbsp;composite&nbsp;=&nbsp;constitch.<a href="#CompositeImage">CompositeImage</a>(executor=executor,&nbsp;debug=True,&nbsp;progress=tqdm.tqdm)<br>
&nbsp;<br>
&nbsp;<br>
Adding&nbsp;the&nbsp;images<br>
&nbsp;<br>
Once&nbsp;the&nbsp;composite&nbsp;is&nbsp;set&nbsp;up&nbsp;we&nbsp;can&nbsp;add&nbsp;the&nbsp;images,&nbsp;and&nbsp;this&nbsp;is&nbsp;done&nbsp;through&nbsp;the&nbsp;<a href="#CompositeImage-add_images">add_images</a>()<br>
method.&nbsp;There&nbsp;are&nbsp;a&nbsp;couple&nbsp;ways&nbsp;of&nbsp;adding&nbsp;images,&nbsp;depending&nbsp;on&nbsp;how&nbsp;much&nbsp;information&nbsp;you&nbsp;have&nbsp;on&nbsp;the&nbsp;images:<br>
&nbsp;<br>
First&nbsp;of&nbsp;all,&nbsp;you&nbsp;can&nbsp;just&nbsp;add&nbsp;the&nbsp;images&nbsp;with&nbsp;no&nbsp;positions,&nbsp;meaning&nbsp;they&nbsp;will&nbsp;all&nbsp;default&nbsp;to&nbsp;being&nbsp;at&nbsp;0,0.<br>
This&nbsp;will&nbsp;work&nbsp;out,&nbsp;as&nbsp;when&nbsp;you&nbsp;calculate&nbsp;constraints&nbsp;between&nbsp;images&nbsp;it&nbsp;will&nbsp;calculate&nbsp;constraints&nbsp;for&nbsp;all<br>
possible&nbsp;images&nbsp;and&nbsp;filter&nbsp;out&nbsp;constraints&nbsp;that&nbsp;have&nbsp;no&nbsp;overlap.&nbsp;However&nbsp;the&nbsp;number&nbsp;of&nbsp;constraints&nbsp;that&nbsp;have<br>
to&nbsp;be&nbsp;calculated&nbsp;grows&nbsp;exponentially&nbsp;with&nbsp;the&nbsp;number&nbsp;of&nbsp;images,&nbsp;and&nbsp;if&nbsp;you&nbsp;have&nbsp;positional&nbsp;information&nbsp;on&nbsp;your<br>
images&nbsp;it&nbsp;is&nbsp;best&nbsp;to&nbsp;pass&nbsp;that&nbsp;in&nbsp;to&nbsp;help&nbsp;with&nbsp;the&nbsp;alignment.&nbsp;If&nbsp;you&nbsp;would&nbsp;like&nbsp;to&nbsp;use&nbsp;this&nbsp;method&nbsp;but&nbsp;are&nbsp;running<br>
into&nbsp;computational&nbsp;limits,&nbsp;the&nbsp;section&nbsp;on&nbsp;pruning&nbsp;constraints&nbsp;below&nbsp;can&nbsp;be&nbsp;helpful.<br>
&nbsp;&nbsp;&nbsp;&nbsp;composite.<a href="#CompositeImage-add_images">add_images</a>(images)<br>
&nbsp;<br>
If&nbsp;your&nbsp;images&nbsp;are&nbsp;taken&nbsp;on&nbsp;a&nbsp;grid&nbsp;you&nbsp;can&nbsp;pass&nbsp;in&nbsp;their&nbsp;positions&nbsp;as&nbsp;grid&nbsp;positions,&nbsp;by&nbsp;setting&nbsp;the&nbsp;scale<br>
parameter&nbsp;to&nbsp;'tile'.&nbsp;For&nbsp;example:<br>
&nbsp;&nbsp;&nbsp;&nbsp;positions=[(0,0),&nbsp;(0,1),&nbsp;(1,0),&nbsp;(1,1)]<br>
&nbsp;&nbsp;&nbsp;&nbsp;composite.<a href="#CompositeImage-add_images">add_images</a>(images,&nbsp;positions=positions,&nbsp;scale='tile')<br>
Now&nbsp;when&nbsp;constraints&nbsp;are&nbsp;calculated&nbsp;only&nbsp;nearby&nbsp;images&nbsp;will&nbsp;be&nbsp;checked,&nbsp;speeding&nbsp;up&nbsp;computation&nbsp;greatly.<br>
&nbsp;<br>
If&nbsp;your&nbsp;images&nbsp;are&nbsp;not&nbsp;on&nbsp;a&nbsp;grid&nbsp;or&nbsp;you&nbsp;have&nbsp;the&nbsp;exact&nbsp;position&nbsp;they&nbsp;were&nbsp;taken&nbsp;in,&nbsp;you&nbsp;can&nbsp;also&nbsp;specify<br>
positions&nbsp;in&nbsp;pixels&nbsp;instead&nbsp;of&nbsp;grid&nbsp;positions,&nbsp;to&nbsp;do&nbsp;this&nbsp;simply&nbsp;set&nbsp;the&nbsp;scale&nbsp;parameter&nbsp;to&nbsp;'pixel'<br>
and&nbsp;the&nbsp;positions&nbsp;passed&nbsp;in&nbsp;will&nbsp;be&nbsp;interpreted&nbsp;as&nbsp;pixel&nbsp;coordinates.&nbsp;When&nbsp;specifying&nbsp;pixel&nbsp;specific<br>
positions&nbsp;another&nbsp;parameter&nbsp;that&nbsp;is&nbsp;available&nbsp;is&nbsp;the&nbsp;uncertainty&nbsp;of&nbsp;the&nbsp;provided&nbsp;positions.&nbsp;If&nbsp;you&nbsp;know<br>
to&nbsp;the&nbsp;pixel&nbsp;where&nbsp;each&nbsp;image&nbsp;is&nbsp;you&nbsp;probably&nbsp;don't&nbsp;have&nbsp;a&nbsp;need&nbsp;for&nbsp;this&nbsp;library,&nbsp;but&nbsp;there&nbsp;is&nbsp;still&nbsp;a<br>
wide&nbsp;range&nbsp;of&nbsp;possibilities,&nbsp;from&nbsp;being&nbsp;precise&nbsp;to&nbsp;a&nbsp;couple&nbsp;pixels&nbsp;to&nbsp;only&nbsp;providing&nbsp;the&nbsp;general&nbsp;locations.<br>
The&nbsp;error&nbsp;on&nbsp;positions&nbsp;can&nbsp;be&nbsp;provided&nbsp;to&nbsp;add_images&nbsp;with&nbsp;the&nbsp;keyword&nbsp;argument&nbsp;positional_error&nbsp;or&nbsp;by&nbsp;directly<br>
setting&nbsp;<a href="#CompositeImage">CompositeImage</a>.positional_error.&nbsp;This&nbsp;will&nbsp;be&nbsp;a&nbsp;pixel&nbsp;value&nbsp;that&nbsp;acts&nbsp;as&nbsp;error&nbsp;bars,&nbsp;meaning&nbsp;the<br>
image&nbsp;positions&nbsp;are&nbsp;plus&nbsp;or&nbsp;minus&nbsp;that&nbsp;value.<br>
&nbsp;<br>
When&nbsp;specifying&nbsp;positions,&nbsp;you&nbsp;can&nbsp;also&nbsp;specify&nbsp;more&nbsp;than&nbsp;two&nbsp;dimensions.&nbsp;The&nbsp;first&nbsp;two&nbsp;are&nbsp;the&nbsp;x&nbsp;and&nbsp;y<br>
dimensions&nbsp;of&nbsp;the&nbsp;images,&nbsp;but&nbsp;a&nbsp;z&nbsp;dimension&nbsp;can&nbsp;be&nbsp;added&nbsp;if&nbsp;you&nbsp;are&nbsp;doing&nbsp;3&nbsp;dimensional&nbsp;stitching&nbsp;or&nbsp;in&nbsp;our&nbsp;case<br>
if&nbsp;you&nbsp;are&nbsp;doing&nbsp;fisseq&nbsp;and&nbsp;want&nbsp;to&nbsp;make&nbsp;sure&nbsp;all&nbsp;the&nbsp;cycles&nbsp;line&nbsp;up&nbsp;perfectly.&nbsp;In&nbsp;the&nbsp;case&nbsp;of&nbsp;fisseq,<br>
you&nbsp;can&nbsp;add&nbsp;the&nbsp;cycle&nbsp;index&nbsp;as&nbsp;the&nbsp;z&nbsp;coordinate&nbsp;for&nbsp;the&nbsp;image.<br>
&nbsp;<br>
&nbsp;<br>
Calculating&nbsp;constraints<br>
&nbsp;<br>
Once&nbsp;images&nbsp;have&nbsp;been&nbsp;added&nbsp;we&nbsp;need&nbsp;to&nbsp;calculate&nbsp;the&nbsp;constraints&nbsp;between&nbsp;overlapping&nbsp;images.<br>
Creating,&nbsp;calculating,&nbsp;filtering,&nbsp;and&nbsp;solving&nbsp;constraints&nbsp;is&nbsp;an&nbsp;integral&nbsp;part&nbsp;of&nbsp;the&nbsp;stitching<br>
algorithm,&nbsp;and&nbsp;a&nbsp;subpackage&nbsp;is&nbsp;dedicated&nbsp;to&nbsp;them,&nbsp;constitch.constraints.&nbsp;This&nbsp;module&nbsp;contains&nbsp;the<br>
<a href="#Constraint">Constraint</a>&nbsp;class,&nbsp;as&nbsp;well&nbsp;as&nbsp;the&nbsp;<a href="#ConstraintSet">ConstraintSet</a>&nbsp;and&nbsp;<a href="#ConstraintFilter">ConstraintFilter</a>&nbsp;classes.&nbsp;Here&nbsp;we&nbsp;will&nbsp;go&nbsp;over&nbsp;the<br>
typical&nbsp;usage&nbsp;of&nbsp;them&nbsp;but&nbsp;for&nbsp;more&nbsp;information&nbsp;consult&nbsp;constitch.constraints.<br>
&nbsp;<br>
The&nbsp;core&nbsp;idea&nbsp;of&nbsp;constraints&nbsp;is&nbsp;that&nbsp;each&nbsp;constraint&nbsp;stores&nbsp;a&nbsp;positional&nbsp;offset&nbsp;between&nbsp;two&nbsp;images,&nbsp;"constraining"<br>
them&nbsp;to&nbsp;have&nbsp;that&nbsp;difference&nbsp;in&nbsp;positions.&nbsp;Constraints&nbsp;are&nbsp;useful&nbsp;for&nbsp;stitching&nbsp;because&nbsp;most&nbsp;alignment&nbsp;algorithms<br>
only&nbsp;work&nbsp;with&nbsp;a&nbsp;pair&nbsp;of&nbsp;images,&nbsp;meaning&nbsp;they&nbsp;take&nbsp;as&nbsp;input&nbsp;and&nbsp;provide&nbsp;as&nbsp;output&nbsp;constraints.<br>
&nbsp;<br>
We&nbsp;can&nbsp;always&nbsp;create&nbsp;new&nbsp;constraints&nbsp;using&nbsp;the&nbsp;attribute&nbsp;<a href="#CompositeImage">CompositeImage</a>.constraints,&nbsp;which&nbsp;generates<br>
constraints&nbsp;using&nbsp;the&nbsp;image&nbsp;positions&nbsp;specified&nbsp;in&nbsp;the&nbsp;composite.&nbsp;To&nbsp;retrieve&nbsp;constraints&nbsp;between&nbsp;all&nbsp;touching<br>
images&nbsp;we&nbsp;can&nbsp;do:<br>
&nbsp;&nbsp;&nbsp;&nbsp;overlapping&nbsp;=&nbsp;composite.constraints(touching=True)<br>
&nbsp;<br>
The&nbsp;constraints&nbsp;here&nbsp;are&nbsp;considered&nbsp;"implicit"&nbsp;constraints&nbsp;as&nbsp;they&nbsp;were&nbsp;created&nbsp;from&nbsp;the&nbsp;provided&nbsp;image&nbsp;positions,<br>
which&nbsp;are&nbsp;not&nbsp;precise.&nbsp;The&nbsp;variable&nbsp;overlapping&nbsp;is&nbsp;a&nbsp;<a href="#ConstraintSet">ConstraintSet</a>&nbsp;class,&nbsp;which&nbsp;acts&nbsp;similar&nbsp;to&nbsp;a&nbsp;dictionary,&nbsp;holding<br>
a&nbsp;set&nbsp;of&nbsp;constraints.&nbsp;Specific&nbsp;constraints&nbsp;can&nbsp;be&nbsp;retrieved&nbsp;by&nbsp;indexing&nbsp;into&nbsp;the&nbsp;set&nbsp;with&nbsp;the&nbsp;indices&nbsp;of&nbsp;the&nbsp;two&nbsp;images<br>
the&nbsp;constraint&nbsp;is&nbsp;between,&nbsp;eg&nbsp;overlapping[1,2]&nbsp;will&nbsp;return&nbsp;the&nbsp;constraint&nbsp;between&nbsp;image&nbsp;1&nbsp;and&nbsp;image&nbsp;2&nbsp;in&nbsp;composite.<br>
&nbsp;<br>
As&nbsp;mentioned&nbsp;before&nbsp;these&nbsp;constraints&nbsp;are&nbsp;not&nbsp;precise,&nbsp;and&nbsp;the&nbsp;next&nbsp;step&nbsp;in&nbsp;stitching&nbsp;is&nbsp;passing<br>
them&nbsp;to&nbsp;an&nbsp;alignment&nbsp;algorithm&nbsp;to&nbsp;refine&nbsp;them.&nbsp;This&nbsp;is&nbsp;done&nbsp;with&nbsp;the&nbsp;<a href="#ConstraintSet">ConstraintSet</a>.calculate()<br>
method,&nbsp;like&nbsp;so:<br>
&nbsp;&nbsp;&nbsp;&nbsp;constraints&nbsp;=&nbsp;overlapping.calculate()<br>
&nbsp;<br>
This&nbsp;creates&nbsp;a&nbsp;new&nbsp;<a href="#ConstraintSet">ConstraintSet</a>&nbsp;constraints,&nbsp;which&nbsp;holds&nbsp;all&nbsp;our&nbsp;new&nbsp;constraints&nbsp;generated&nbsp;by&nbsp;the&nbsp;<a href="#Aligner">Aligner</a>&nbsp;class<br>
passed&nbsp;to&nbsp;calculate.&nbsp;By&nbsp;default&nbsp;constitch.<a href="#FFTAligner">FFTAligner</a>()&nbsp;is&nbsp;used,&nbsp;which&nbsp;runs&nbsp;the&nbsp;phase&nbsp;correlation&nbsp;algorithm&nbsp;to<br>
find&nbsp;the&nbsp;offset&nbsp;with&nbsp;the&nbsp;maximum&nbsp;correlation.<br>
&nbsp;<br>
&nbsp;<br>
Filtering&nbsp;constraints<br>
&nbsp;<br>
With&nbsp;the&nbsp;constraints&nbsp;calculated&nbsp;we&nbsp;can&nbsp;filter&nbsp;out&nbsp;any&nbsp;erroneous&nbsp;constraints&nbsp;using&nbsp;the&nbsp;constraint&nbsp;scores:<br>
&nbsp;&nbsp;&nbsp;&nbsp;constraints&nbsp;=&nbsp;constraints.filter(min_score=0.5)<br>
&nbsp;<br>
This&nbsp;will&nbsp;only&nbsp;keep&nbsp;constraints&nbsp;with&nbsp;a&nbsp;score&nbsp;&gt;=&nbsp;0.5,&nbsp;which&nbsp;should&nbsp;eliminate&nbsp;almost&nbsp;all&nbsp;of&nbsp;the&nbsp;constraints<br>
that&nbsp;are&nbsp;not&nbsp;accurate.&nbsp;To&nbsp;futher&nbsp;filter&nbsp;the&nbsp;constraints&nbsp;we&nbsp;can&nbsp;fit&nbsp;a&nbsp;linear&nbsp;model&nbsp;to&nbsp;the&nbsp;constraints&nbsp;that&nbsp;remain:<br>
&nbsp;&nbsp;&nbsp;&nbsp;stage_model&nbsp;=&nbsp;constraints.fit_model(outliers=True)<br>
&nbsp;&nbsp;&nbsp;&nbsp;constraints&nbsp;=&nbsp;stage_model.inliers<br>
&nbsp;<br>
When&nbsp;fitting&nbsp;a&nbsp;linear&nbsp;model&nbsp;to&nbsp;the&nbsp;constraints,&nbsp;we&nbsp;can&nbsp;use&nbsp;an&nbsp;outlier&nbsp;resistant&nbsp;model&nbsp;by&nbsp;specifying&nbsp;outliers=True,<br>
which&nbsp;uses&nbsp;RANSAC&nbsp;to&nbsp;classify&nbsp;some&nbsp;constraints&nbsp;as&nbsp;outliers.&nbsp;We&nbsp;can&nbsp;additionally&nbsp;use&nbsp;the&nbsp;stage&nbsp;model&nbsp;to&nbsp;estimate<br>
constrains&nbsp;that&nbsp;were&nbsp;filtered&nbsp;out&nbsp;before:<br>
&nbsp;&nbsp;&nbsp;&nbsp;model_constraints&nbsp;=&nbsp;overlapping.calculate(stage_model)<br>
&nbsp;<br>
As&nbsp;you&nbsp;can&nbsp;see&nbsp;here,&nbsp;the&nbsp;stage_model&nbsp;is&nbsp;an&nbsp;<a href="#Aligner">Aligner</a>&nbsp;class&nbsp;that&nbsp;can&nbsp;be&nbsp;used&nbsp;to&nbsp;calculate&nbsp;new&nbsp;constraints,<br>
with&nbsp;the&nbsp;same&nbsp;interface&nbsp;as&nbsp;the&nbsp;<a href="#FFTAligner">FFTAligner</a>.&nbsp;We&nbsp;can&nbsp;merge&nbsp;these&nbsp;two&nbsp;constraint&nbsp;sets&nbsp;together&nbsp;to&nbsp;replace&nbsp;any<br>
constraints&nbsp;that&nbsp;were&nbsp;filtered&nbsp;out&nbsp;with&nbsp;the&nbsp;modeled&nbsp;constraints:<br>
&nbsp;&nbsp;&nbsp;&nbsp;constraints&nbsp;=&nbsp;constraints.<a href="#CompositeImage-merge">merge</a>(model_constraints)<br>
&nbsp;<br>
&nbsp;<br>
Solving&nbsp;constraints<br>
&nbsp;<br>
The&nbsp;final&nbsp;step&nbsp;is&nbsp;to&nbsp;solve&nbsp;the&nbsp;constraints&nbsp;that&nbsp;have&nbsp;been&nbsp;calculated,&nbsp;which&nbsp;we&nbsp;can&nbsp;do&nbsp;with&nbsp;the&nbsp;<a href="#ConstraintSet">ConstraintSet</a>.solve()<br>
method.&nbsp;This&nbsp;converts&nbsp;each&nbsp;constraint&nbsp;into&nbsp;two&nbsp;linear&nbsp;equations,&nbsp;and&nbsp;solves&nbsp;the&nbsp;system&nbsp;of&nbsp;equations&nbsp;to&nbsp;find&nbsp;the<br>
image&nbsp;positions&nbsp;that&nbsp;minimize&nbsp;alignment&nbsp;error.&nbsp;We&nbsp;can&nbsp;then&nbsp;apply&nbsp;these&nbsp;positions&nbsp;to&nbsp;the&nbsp;composite&nbsp;with&nbsp;<a href="#CompositeImage">CompositeImage</a>.<a href="#CompositeImage-setpositions">setpositions</a>():<br>
&nbsp;&nbsp;&nbsp;&nbsp;solution&nbsp;=&nbsp;constraints.solve()<br>
&nbsp;&nbsp;&nbsp;&nbsp;composite.<a href="#CompositeImage-setpositions">setpositions</a>(solution)<br>
&nbsp;<br>
Creating&nbsp;the&nbsp;final&nbsp;image<br>
&nbsp;<br>
To&nbsp;get&nbsp;the&nbsp;final&nbsp;merged&nbsp;composite&nbsp;image&nbsp;we&nbsp;can&nbsp;call&nbsp;the&nbsp;<a href="#CompositeImage">CompositeImage</a>.<a href="#CompositeImage-stitch">stitch</a>()&nbsp;function,&nbsp;which&nbsp;combines&nbsp;all&nbsp;individual&nbsp;images<br>
based&nbsp;on&nbsp;the&nbsp;current&nbsp;image&nbsp;positions:<br>
&nbsp;&nbsp;&nbsp;&nbsp;final_image&nbsp;=&nbsp;composite.<a href="#CompositeImage-stitch">stitch</a>()<br>
&nbsp;<br>
The&nbsp;method&nbsp;that&nbsp;this&nbsp;function&nbsp;merges&nbsp;the&nbsp;images&nbsp;together&nbsp;can&nbsp;be&nbsp;configured&nbsp;by&nbsp;passing&nbsp;a&nbsp;<a href="#Merger">Merger</a>&nbsp;instance,<br>
by&nbsp;default&nbsp;it&nbsp;will&nbsp;use&nbsp;<a href="#MeanMerger">MeanMerger</a>.&nbsp;More&nbsp;information&nbsp;on&nbsp;mergers&nbsp;can&nbsp;be&nbsp;found&nbsp;in&nbsp;the&nbsp;docs&nbsp;of&nbsp;the&nbsp;constitch.<a href="#Merger">Merger</a>&nbsp;class<br>
and&nbsp;the&nbsp;constitch.merging&nbsp;module.<br>
&nbsp;<br>
For&nbsp;each&nbsp;of&nbsp;these&nbsp;steps&nbsp;there&nbsp;are&nbsp;many&nbsp;different&nbsp;parameters&nbsp;to&nbsp;configure&nbsp;the&nbsp;behaviour,&nbsp;make&nbsp;sure&nbsp;to&nbsp;check&nbsp;out&nbsp;the&nbsp;documentation<br>
for&nbsp;each&nbsp;method&nbsp;to&nbsp;see&nbsp;the&nbsp;details&nbsp;on&nbsp;how&nbsp;they&nbsp;work.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="CompositeImage-__init__"><strong>__init__</strong></a>(self, images=None, positions=None, boxes=None, scale='pixel', channel_axis=None, grid_size=None, tile_shape=None, overlap=0.1, aligner=None, precalculate=False, debug=True, progress=False, executor=None)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="CompositeImage-add_image"><strong>add_image</strong></a>(self, image, position=None, box=None, scale='pixel', imagescale=1)</dt></dl>

<dl><dt><a name="CompositeImage-add_images"><strong>add_images</strong></a>(self, images, positions=None, boxes=None, scale='pixel', channel_axis=None, imagescale=1)</dt><dd><tt>Adds&nbsp;images&nbsp;to&nbsp;the&nbsp;composite<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;images&nbsp;(np.ndarray&nbsp;shape&nbsp;(N,&nbsp;W,&nbsp;H)&nbsp;or&nbsp;list&nbsp;of&nbsp;N&nbsp;np.ndarrays&nbsp;shape&nbsp;(W,&nbsp;H)&nbsp;or&nbsp;list&nbsp;of&nbsp;strings):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;images&nbsp;that&nbsp;will&nbsp;be&nbsp;stitched&nbsp;together.&nbsp;Can&nbsp;pass&nbsp;a&nbsp;list&nbsp;of<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;paths&nbsp;that&nbsp;will&nbsp;be&nbsp;opened&nbsp;by&nbsp;imageio.v3.imread&nbsp;when&nbsp;needed.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Passing&nbsp;paths&nbsp;will&nbsp;require&nbsp;less&nbsp;memory&nbsp;as&nbsp;images&nbsp;are&nbsp;not&nbsp;stored,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;but&nbsp;will&nbsp;increase&nbsp;computation&nbsp;time.<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;positions&nbsp;(np.ndarray&nbsp;shape&nbsp;(N,&nbsp;D)&nbsp;):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies&nbsp;the&nbsp;extimated&nbsp;positions&nbsp;of&nbsp;each&nbsp;image.&nbsp;The&nbsp;approx&nbsp;values&nbsp;are<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;used&nbsp;to&nbsp;decide&nbsp;which&nbsp;images&nbsp;are&nbsp;overlapping.&nbsp;These&nbsp;values&nbsp;are&nbsp;interpreted<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;using&nbsp;the&nbsp;scale&nbsp;argument,&nbsp;default&nbsp;they&nbsp;are&nbsp;pixel&nbsp;values.<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;boxes&nbsp;(sequence&nbsp;of&nbsp;<a href="#BBox">BBox</a>):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An&nbsp;alternative&nbsp;to&nbsp;specifying&nbsp;the&nbsp;positions,&nbsp;the&nbsp;full&nbsp;bounding&nbsp;boxes&nbsp;of&nbsp;every&nbsp;image&nbsp;can&nbsp;also<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;be&nbsp;passed&nbsp;in.&nbsp;The&nbsp;units&nbsp;of&nbsp;the&nbsp;boxes&nbsp;are&nbsp;interpreted&nbsp;the&nbsp;same&nbsp;as&nbsp;image&nbsp;positions,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with&nbsp;the&nbsp;scale&nbsp;argument&nbsp;deciding&nbsp;their&nbsp;relation&nbsp;to&nbsp;the&nbsp;scale&nbsp;of&nbsp;pixels.<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;scale&nbsp;('pixel',&nbsp;'tile',&nbsp;float,&nbsp;or&nbsp;sequence):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;scale&nbsp;argument&nbsp;is&nbsp;used&nbsp;to&nbsp;interpret&nbsp;the&nbsp;position&nbsp;values&nbsp;given.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'pixel'&nbsp;means&nbsp;the&nbsp;values&nbsp;are&nbsp;pixel&nbsp;values,&nbsp;equivalent&nbsp;to&nbsp;putting&nbsp;1.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'tile'&nbsp;means&nbsp;the&nbsp;values&nbsp;are&nbsp;indices&nbsp;in&nbsp;a&nbsp;tile&nbsp;grid,&nbsp;eg&nbsp;a&nbsp;unit&nbsp;of&nbsp;1&nbsp;is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;width&nbsp;of&nbsp;an&nbsp;image.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;float&nbsp;value&nbsp;means&nbsp;the&nbsp;position&nbsp;values&nbsp;are&nbsp;a&nbsp;units&nbsp;where&nbsp;one&nbsp;unit&nbsp;is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;given&nbsp;number&nbsp;of&nbsp;pixels.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;a&nbsp;sequence&nbsp;is&nbsp;given,&nbsp;each&nbsp;element&nbsp;can&nbsp;be&nbsp;any&nbsp;of&nbsp;the&nbsp;previous&nbsp;values,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;which&nbsp;are&nbsp;applied&nbsp;to&nbsp;each&nbsp;axis.</tt></dd></dl>

<dl><dt><a name="CompositeImage-add_split_image"><strong>add_split_image</strong></a>(self, image, grid_size=None, tile_shape=None, overlap=0.1, channel_axis=None)</dt><dd><tt>Adds&nbsp;an&nbsp;image&nbsp;split&nbsp;into&nbsp;a&nbsp;number&nbsp;of&nbsp;tiles.&nbsp;This&nbsp;can&nbsp;be&nbsp;used&nbsp;to&nbsp;divide&nbsp;up<br>
a&nbsp;large&nbsp;image&nbsp;into&nbsp;smaller&nbsp;pieces&nbsp;for&nbsp;efficient&nbsp;processing.&nbsp;The&nbsp;resulting<br>
images&nbsp;are&nbsp;guaranteed&nbsp;to&nbsp;all&nbsp;be&nbsp;the&nbsp;same&nbsp;size.<br>
A&nbsp;common&nbsp;pattern&nbsp;would&nbsp;be:<br>
&nbsp;<br>
composite.<a href="#CompositeImage-add_split_image">add_split_image</a>(image,&nbsp;10)<br>
for&nbsp;i&nbsp;in&nbsp;range(len(composite.images)):<br>
&nbsp;&nbsp;&nbsp;&nbsp;composite.images[i]&nbsp;=&nbsp;process(composite.images[i])<br>
result&nbsp;=&nbsp;composite.stitch_images()<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;image:&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;image&nbsp;that&nbsp;will&nbsp;be&nbsp;split&nbsp;into&nbsp;tiles<br>
&nbsp;&nbsp;&nbsp;&nbsp;grid_size:&nbsp;int&nbsp;or&nbsp;(int,&nbsp;int)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;number&nbsp;of&nbsp;tiles&nbsp;to&nbsp;split&nbsp;the&nbsp;image&nbsp;into.&nbsp;Either&nbsp;this&nbsp;or&nbsp;tile_shape<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;should&nbsp;be&nbsp;specified.<br>
&nbsp;&nbsp;&nbsp;&nbsp;tile_shape:&nbsp;(int,&nbsp;int)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;shape&nbsp;of&nbsp;the&nbsp;resulting&nbsp;tiles,&nbsp;if&nbsp;grid_size&nbsp;isn't&nbsp;specified&nbsp;the&nbsp;maximum<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number&nbsp;of&nbsp;tiles&nbsp;that&nbsp;fit&nbsp;in&nbsp;the&nbsp;image&nbsp;are&nbsp;extracted.&nbsp;Whether&nbsp;specified&nbsp;or&nbsp;not,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;size&nbsp;of&nbsp;all&nbsp;tiles&nbsp;created&nbsp;is&nbsp;guaranteed&nbsp;to&nbsp;be&nbsp;uniform.<br>
&nbsp;&nbsp;&nbsp;&nbsp;overlap:&nbsp;float,&nbsp;int&nbsp;or&nbsp;(float&nbsp;or&nbsp;int,&nbsp;float&nbsp;or&nbsp;int)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;amount&nbsp;of&nbsp;overlap&nbsp;between&nbsp;neighboring&nbsp;tiles.&nbsp;Zero&nbsp;will&nbsp;result&nbsp;in&nbsp;no&nbsp;overlap,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;floating&nbsp;point&nbsp;number&nbsp;represents&nbsp;a&nbsp;percentage&nbsp;of&nbsp;the&nbsp;size&nbsp;of&nbsp;the&nbsp;tile,&nbsp;and&nbsp;an<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;integer&nbsp;number&nbsp;represents&nbsp;a&nbsp;flat&nbsp;pixel&nbsp;overlap.&nbsp;The&nbsp;overlap&nbsp;is&nbsp;treated&nbsp;as&nbsp;a&nbsp;lower&nbsp;bound,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;as&nbsp;it&nbsp;is&nbsp;not&nbsp;always&nbsp;possible&nbsp;to&nbsp;get&nbsp;the&nbsp;exact&nbsp;overlap&nbsp;requested&nbsp;due&nbsp;to&nbsp;rounding&nbsp;issues,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;in&nbsp;some&nbsp;cases&nbsp;more&nbsp;overlap&nbsp;will&nbsp;exist&nbsp;between&nbsp;some&nbsp;tiles</tt></dd></dl>

<dl><dt><a name="CompositeImage-align_disconnected_regions"><strong>align_disconnected_regions</strong></a>(self, num_test_points=0.05, expand_range=5)</dt><dd><tt>Looks&nbsp;at&nbsp;the&nbsp;current&nbsp;constraints&nbsp;in&nbsp;this&nbsp;composite&nbsp;and&nbsp;sees&nbsp;if&nbsp;there&nbsp;are&nbsp;any&nbsp;images&nbsp;or<br>
groups&nbsp;of&nbsp;images&nbsp;that&nbsp;are&nbsp;fully&nbsp;disconnected&nbsp;from&nbsp;the&nbsp;rest&nbsp;of&nbsp;the&nbsp;images.&nbsp;If&nbsp;any&nbsp;are&nbsp;found,<br>
they&nbsp;are&nbsp;attempted&nbsp;to&nbsp;be&nbsp;joined&nbsp;back&nbsp;together&nbsp;by&nbsp;calculating&nbsp;select&nbsp;constraints&nbsp;between&nbsp;the<br>
two&nbsp;groups</tt></dd></dl>

<dl><dt><a name="CompositeImage-calc_score_threshold"><strong>calc_score_threshold</strong></a>(self, num_samples=None, random_state=12345)</dt><dd><tt>Estimates&nbsp;a&nbsp;threshold&nbsp;for&nbsp;selecting&nbsp;constraints&nbsp;with&nbsp;good&nbsp;overlap.<br>
&nbsp;<br>
Done&nbsp;by&nbsp;calculating&nbsp;random&nbsp;constraints&nbsp;and&nbsp;using&nbsp;a&nbsp;gaussian&nbsp;mixture&nbsp;model<br>
to&nbsp;distinguish&nbsp;random&nbsp;constraints&nbsp;from&nbsp;real&nbsp;constraints<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;num_samples&nbsp;(float):&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;number&nbsp;of&nbsp;fake&nbsp;constraints&nbsp;to&nbsp;be&nbsp;generated,&nbsp;defaults&nbsp;to&nbsp;0.25*len(images).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In&nbsp;general&nbsp;the&nbsp;more&nbsp;samples&nbsp;the&nbsp;better&nbsp;the&nbsp;estimate,&nbsp;at&nbsp;the&nbsp;expense&nbsp;of&nbsp;speed<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;random_state&nbsp;(int):&nbsp;Used&nbsp;as&nbsp;a&nbsp;seed&nbsp;to&nbsp;get&nbsp;reproducible&nbsp;results<br>
&nbsp;<br>
Returns&nbsp;(float):<br>
&nbsp;&nbsp;&nbsp;&nbsp;threshold&nbsp;for&nbsp;score&nbsp;where&nbsp;all&nbsp;scores&nbsp;lower&nbsp;are&nbsp;likely&nbsp;to&nbsp;be&nbsp;bad&nbsp;constraints</tt></dd></dl>

<dl><dt><a name="CompositeImage-constraint_error"><strong>constraint_error</strong></a>(self, i, j, constraint)</dt></dl>

<dl><dt><a name="CompositeImage-copy"><strong>copy</strong></a>(self, **kwargs)</dt><dd><tt>Creates&nbsp;a&nbsp;full&nbsp;copy&nbsp;of&nbsp;this&nbsp;composite.&nbsp;The&nbsp;only&nbsp;thing&nbsp;shared&nbsp;between&nbsp;this&nbsp;composite<br>
and&nbsp;the&nbsp;new&nbsp;copy&nbsp;is&nbsp;the&nbsp;raw&nbsp;image&nbsp;data.</tt></dd></dl>

<dl><dt><a name="CompositeImage-html_summary"><strong>html_summary</strong></a>(self, path, score_func=None)</dt></dl>

<dl><dt><a name="CompositeImage-layer"><strong>layer</strong></a>(self, index)</dt><dd><tt>Returns&nbsp;a&nbsp;SubComposite&nbsp;with&nbsp;only&nbsp;images&nbsp;that&nbsp;are&nbsp;on&nbsp;the&nbsp;specified&nbsp;layer,&nbsp;that&nbsp;is<br>
all&nbsp;images&nbsp;where&nbsp;box.position[2]&nbsp;==&nbsp;index.<br>
Layers&nbsp;can&nbsp;be&nbsp;created&nbsp;when&nbsp;calling&nbsp;<a href="#CompositeImage-merge">merge</a>()&nbsp;with&nbsp;new_layer=True<br>
or&nbsp;manually&nbsp;by&nbsp;specifying&nbsp;a&nbsp;third&nbsp;dimension&nbsp;when&nbsp;adding&nbsp;images</tt></dd></dl>

<dl><dt><a name="CompositeImage-merge"><strong>merge</strong></a>(self, other_composite, *other_constraint_sets, new_layer=False, align_coords=False)</dt><dd><tt>Adds&nbsp;all&nbsp;images&nbsp;and&nbsp;constraints&nbsp;from&nbsp;another&nbsp;montage&nbsp;into&nbsp;this&nbsp;one.<br>
&nbsp;<br>
other_composite:&nbsp;<a href="#CompositeImage">CompositeImage</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;Another&nbsp;composite&nbsp;instance&nbsp;that&nbsp;will&nbsp;be&nbsp;added&nbsp;to&nbsp;this&nbsp;one.&nbsp;All&nbsp;images&nbsp;from<br>
&nbsp;&nbsp;&nbsp;&nbsp;it&nbsp;are&nbsp;added&nbsp;to&nbsp;this&nbsp;instance.&nbsp;All&nbsp;image&nbsp;positions&nbsp;are&nbsp;added,&nbsp;mantaining<br>
&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;scale_factors&nbsp;of&nbsp;both&nbsp;composites.<br>
&nbsp;<br>
Returns:&nbsp;list&nbsp;of&nbsp;indices<br>
&nbsp;&nbsp;&nbsp;&nbsp;returns&nbsp;the&nbsp;list&nbsp;of&nbsp;indices&nbsp;of&nbsp;the&nbsp;images&nbsp;added&nbsp;from&nbsp;the&nbsp;other&nbsp;composite.</tt></dd></dl>

<dl><dt><a name="CompositeImage-pair_func"><strong>pair_func</strong></a>(self)</dt></dl>

<dl><dt><a name="CompositeImage-plot_scores"><strong>plot_scores</strong></a>(self, path, constraints=None, score_func=None, axis_size=12)</dt></dl>

<dl><dt><a name="CompositeImage-print_mem_usage"><strong>print_mem_usage</strong></a>(self)</dt></dl>

<dl><dt><a name="CompositeImage-random_pair_func"><strong>random_pair_func</strong></a>(self)</dt></dl>

<dl><dt><a name="CompositeImage-resized_image"><strong>resized_image</strong></a>(self, index, scale_x, scale_y)</dt><dd><tt>Returns&nbsp;the&nbsp;image&nbsp;at&nbsp;self.<strong>images</strong>[index]&nbsp;but&nbsp;upscaled&nbsp;or&nbsp;downscaled<br>
by&nbsp;scale_x&nbsp;and&nbsp;scale_y.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;index&nbsp;(int):&nbsp;index&nbsp;of&nbsp;image<br>
&nbsp;&nbsp;&nbsp;&nbsp;scale_x&nbsp;(int,&nbsp;float,&nbsp;fractions.Fraction):&nbsp;The&nbsp;scale&nbsp;multiplier&nbsp;across&nbsp;the&nbsp;x&nbsp;axis<br>
&nbsp;&nbsp;&nbsp;&nbsp;scale_x&nbsp;(int,&nbsp;float,&nbsp;fractions.Fraction):&nbsp;The&nbsp;scale&nbsp;multiplier&nbsp;across&nbsp;the&nbsp;y&nbsp;axis</tt></dd></dl>

<dl><dt><a name="CompositeImage-score_heatmap"><strong>score_heatmap</strong></a>(self, path, score_func=None)</dt></dl>

<dl><dt><a name="CompositeImage-set_aligner"><strong>set_aligner</strong></a>(self, aligner, rescore_constraints=False)</dt></dl>

<dl><dt><a name="CompositeImage-set_executor"><strong>set_executor</strong></a>(self, executor)</dt></dl>

<dl><dt><a name="CompositeImage-set_logging"><strong>set_logging</strong></a>(self, debug=True, progress=False)</dt></dl>

<dl><dt><a name="CompositeImage-set_scale"><strong>set_scale</strong></a>(self, scale_factor)</dt><dd><tt>Sets&nbsp;the&nbsp;scale&nbsp;factor&nbsp;of&nbsp;the&nbsp;composite.&nbsp;Normally&nbsp;this&nbsp;doesn't&nbsp;need&nbsp;to&nbsp;be&nbsp;changed,<br>
however&nbsp;if&nbsp;you&nbsp;are&nbsp;trying&nbsp;to&nbsp;stich&nbsp;together&nbsp;images&nbsp;taken&nbsp;at&nbsp;different&nbsp;magnifications&nbsp;you<br>
may&nbsp;need&nbsp;to&nbsp;modify&nbsp;the&nbsp;scale&nbsp;factor.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;scale_factor:&nbsp;float&nbsp;or&nbsp;int<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scale&nbsp;of&nbsp;images&nbsp;in&nbsp;this&nbsp;composite,&nbsp;as&nbsp;a&nbsp;multiplier.&nbsp;Eg&nbsp;a&nbsp;scale_factor&nbsp;of<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10&nbsp;will&nbsp;result&nbsp;in&nbsp;each&nbsp;pixel&nbsp;in&nbsp;images&nbsp;corresponding&nbsp;to&nbsp;10&nbsp;pixels&nbsp;in&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output&nbsp;of&nbsp;functions&nbsp;like&nbsp;`<a href="#CompositeImage">CompositeImage</a>.stitch_images()`&nbsp;or&nbsp;when&nbsp;merging&nbsp;composites&nbsp;together.</tt></dd></dl>

<dl><dt><a name="CompositeImage-setimages"><strong>setimages</strong></a>(self, images)</dt><dd><tt>Updates&nbsp;the&nbsp;images&nbsp;of&nbsp;this&nbsp;composite.<br>
&nbsp;<br>
images&nbsp;(sequence&nbsp;or&nbsp;dict):&nbsp;The&nbsp;new&nbsp;images&nbsp;to&nbsp;be&nbsp;set<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;a&nbsp;sequence,&nbsp;it&nbsp;must&nbsp;be&nbsp;the&nbsp;current&nbsp;length&nbsp;of&nbsp;self.<strong>images</strong>.&nbsp;Each<br>
&nbsp;&nbsp;&nbsp;&nbsp;image&nbsp;is&nbsp;updated&nbsp;with&nbsp;the&nbsp;corresponding&nbsp;new&nbsp;image&nbsp;in&nbsp;the&nbsp;sequence.<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;a&nbsp;dict,&nbsp;it&nbsp;must&nbsp;map&nbsp;from&nbsp;indices&nbsp;within&nbsp;the&nbsp;range&nbsp;[0,&nbsp;len(self.<strong>images</strong>))<br>
&nbsp;&nbsp;&nbsp;&nbsp;to&nbsp;new&nbsp;images,&nbsp;that&nbsp;are&nbsp;set&nbsp;at&nbsp;said&nbsp;indices.<br>
&nbsp;&nbsp;&nbsp;&nbsp;All&nbsp;images&nbsp;must&nbsp;be&nbsp;numpy&nbsp;arrays&nbsp;of&nbsp;shape&nbsp;either&nbsp;(W,&nbsp;H)&nbsp;or&nbsp;(W,&nbsp;H,&nbsp;C).</tt></dd></dl>

<dl><dt><a name="CompositeImage-setpositions"><strong>setpositions</strong></a>(self, positions)</dt><dd><tt>Applies&nbsp;new&nbsp;positions&nbsp;to&nbsp;images&nbsp;in&nbsp;this&nbsp;composite.&nbsp;positions&nbsp;is&nbsp;either&nbsp;a&nbsp;dict<br>
mapping&nbsp;image&nbsp;indices&nbsp;to&nbsp;new&nbsp;positions,&nbsp;a&nbsp;sequence&nbsp;of&nbsp;new&nbsp;positions,&nbsp;or&nbsp;a&nbsp;constitch.<a href="#Solver">Solver</a><br>
class&nbsp;that&nbsp;has&nbsp;had&nbsp;solve()&nbsp;run&nbsp;on&nbsp;it,&nbsp;usually&nbsp;from&nbsp;<a href="#ConstraintSet">ConstraintSet</a>.solve</tt></dd></dl>

<dl><dt><a name="CompositeImage-stitch"><strong>stitch</strong></a>(self, merger='mean', indices=None, real_images=None, out=None, bg_value=None, return_bg_mask=False, mins=None, maxes=None, keep_zero=False)</dt><dd><tt>Combines&nbsp;images&nbsp;in&nbsp;the&nbsp;composite&nbsp;into&nbsp;a&nbsp;single&nbsp;image<br>
&nbsp;<br>
merger:&nbsp;str&nbsp;or&nbsp;merging.<a href="#Merger">Merger</a>&nbsp;instance<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;merger&nbsp;used&nbsp;to&nbsp;combine&nbsp;overlapping&nbsp;regions&nbsp;of&nbsp;images.&nbsp;If&nbsp;a&nbsp;string&nbsp;it&nbsp;is&nbsp;mapped&nbsp;to&nbsp;a&nbsp;<a href="#Merger">Merger</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;as&nbsp;follows:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"mean":&nbsp;merging.<a href="#MeanMerger">MeanMerger</a>,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"efficient_mean":&nbsp;merging.<a href="#EfficientMeanMerger">EfficientMeanMerger</a>,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"last":&nbsp;merging.<a href="#LastMerger">LastMerger</a>,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"nearest":&nbsp;merging.<a href="#NearestMerger">NearestMerger</a>,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"efficient_nearest":&nbsp;merging.<a href="#EfficientNearestMerger">EfficientNearestMerger</a>,<br>
&nbsp;<br>
indices:&nbsp;sequence&nbsp;of&nbsp;int<br>
&nbsp;&nbsp;&nbsp;&nbsp;Indices&nbsp;of&nbsp;images&nbsp;in&nbsp;the&nbsp;composite&nbsp;to&nbsp;be&nbsp;stitched&nbsp;together<br>
&nbsp;<br>
real_images:&nbsp;sequence&nbsp;of&nbsp;np.ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;An&nbsp;alternative&nbsp;image&nbsp;list&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;the&nbsp;stitching,&nbsp;instead&nbsp;of<br>
&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;stored&nbsp;images.&nbsp;Must&nbsp;be&nbsp;same&nbsp;length&nbsp;and&nbsp;each&nbsp;image&nbsp;must&nbsp;have&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;first&nbsp;two&nbsp;dimensions&nbsp;the&nbsp;same&nbsp;size&nbsp;as&nbsp;self.<strong>images</strong><br>
&nbsp;<br>
bg_value:&nbsp;scalar&nbsp;or&nbsp;array<br>
&nbsp;&nbsp;&nbsp;&nbsp;Value&nbsp;to&nbsp;fill&nbsp;empty&nbsp;areas&nbsp;of&nbsp;the&nbsp;image.<br>
&nbsp;<br>
return_bg_mask:&nbsp;bool<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True&nbsp;a&nbsp;boolean&nbsp;mask&nbsp;of&nbsp;the&nbsp;background,&nbsp;pixels&nbsp;with&nbsp;no&nbsp;images<br>
&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;them,&nbsp;is&nbsp;returned.<br>
&nbsp;<br>
keep_zero:&nbsp;bool<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;or&nbsp;not&nbsp;to&nbsp;keep&nbsp;the&nbsp;origin&nbsp;in&nbsp;the&nbsp;result.&nbsp;If&nbsp;true&nbsp;this&nbsp;could<br>
&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;in&nbsp;extra&nbsp;blank&nbsp;space,&nbsp;which&nbsp;might&nbsp;be&nbsp;necessary&nbsp;when&nbsp;lining&nbsp;up<br>
&nbsp;&nbsp;&nbsp;&nbsp;multiple&nbsp;images.<br>
&nbsp;<br>
Returns:&nbsp;np.ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;image&nbsp;stitched&nbsp;together</tt></dd></dl>

<dl><dt><a name="CompositeImage-subcomposite"><strong>subcomposite</strong></a>(self, indices, **kwargs)</dt><dd><tt>Returns&nbsp;a&nbsp;new&nbsp;composite&nbsp;with&nbsp;a&nbsp;subset&nbsp;of&nbsp;the&nbsp;images&nbsp;and&nbsp;constraints&nbsp;in&nbsp;this&nbsp;one.<br>
The&nbsp;images&nbsp;and&nbsp;positions&nbsp;are&nbsp;shared,&nbsp;so&nbsp;modifing&nbsp;them&nbsp;on&nbsp;the&nbsp;new&nbsp;composite&nbsp;will<br>
change&nbsp;them&nbsp;on&nbsp;the&nbsp;original.<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;indices:&nbsp;sequence&nbsp;of&nbsp;ints,&nbsp;sequence&nbsp;of&nbsp;bools,&nbsp;function<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;way&nbsp;to&nbsp;select&nbsp;the&nbsp;images&nbsp;to&nbsp;be&nbsp;included&nbsp;in&nbsp;the&nbsp;new&nbsp;composite.&nbsp;Can&nbsp;be:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;sequence&nbsp;of&nbsp;indices,&nbsp;a&nbsp;sequence&nbsp;of&nbsp;boolean&nbsp;values&nbsp;the&nbsp;same&nbsp;length&nbsp;as&nbsp;images,<br>
&nbsp;&nbsp;&nbsp;&nbsp;kwargs:&nbsp;arguments&nbsp;passed&nbsp;to&nbsp;the&nbsp;constructor&nbsp;of&nbsp;the&nbsp;subcomposite</tt></dd></dl>

<dl><dt><a name="CompositeImage-to_obj"><strong>to_obj</strong></a>(self)</dt></dl>

<hr>
Class methods defined here:<br>
<dl><dt><a name="CompositeImage-from_obj"><strong>from_obj</strong></a>(obj, **kwargs)<font color="#909090"><font face="helvetica, arial"> from <a href="builtins.html#type">builtins.type</a></font></font></dt></dl>

<hr>
Readonly properties defined here:<br>
<dl><dt><strong>positions</strong></dt>
</dl>
<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Constraint">class <strong>Constraint</strong></a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Constraint">Constraint</a>(composite,&nbsp;index1=None,&nbsp;index2=None,&nbsp;dx=None,&nbsp;dy=None,&nbsp;score=None,&nbsp;error=None,&nbsp;type=&amp;lt;ConstraintType.NORMAL:&nbsp;'normal'&amp;gt;)<br>
&nbsp;<br>
A&nbsp;class&nbsp;to&nbsp;represent&nbsp;the&nbsp;pixel&nbsp;offset&nbsp;between&nbsp;two&nbsp;images&nbsp;in&nbsp;a&nbsp;composite.<br>
&nbsp;<br>
The&nbsp;<a href="#Constraint">Constraint</a>&nbsp;is&nbsp;an&nbsp;important&nbsp;component&nbsp;of&nbsp;the&nbsp;ConStitch&nbsp;algorithm,&nbsp;and&nbsp;converting<br>
from&nbsp;global&nbsp;positions&nbsp;of&nbsp;images&nbsp;to&nbsp;a&nbsp;set&nbsp;of&nbsp;constraints&nbsp;between&nbsp;images&nbsp;and&nbsp;back<br>
is&nbsp;the&nbsp;main&nbsp;algorithm&nbsp;used&nbsp;to&nbsp;stitch&nbsp;image&nbsp;sets.<br>
&nbsp;<br>
It&nbsp;is&nbsp;not&nbsp;normally&nbsp;necessary&nbsp;to&nbsp;instantiate&nbsp;<a href="#Constraint">Constraint</a>&nbsp;objects&nbsp;directly,&nbsp;instead<br>
they&nbsp;are&nbsp;created&nbsp;from&nbsp;the&nbsp;existing&nbsp;image&nbsp;positions&nbsp;with&nbsp;<a href="#CompositeImage">CompositeImage</a>.constraints<br>
or&nbsp;by&nbsp;calculating&nbsp;new&nbsp;constraints&nbsp;with&nbsp;the&nbsp;<a href="#Constraint">Constraint</a>.calculate&nbsp;or&nbsp;<a href="#ConstraintSet">ConstraintSet</a>.calculate<br>
functions.<br>
&nbsp;<br>
The&nbsp;class&nbsp;<a href="#ConstraintSet">ConstraintSet</a>&nbsp;is&nbsp;used&nbsp;as&nbsp;a&nbsp;container&nbsp;to&nbsp;manipulate&nbsp;and&nbsp;filter&nbsp;large&nbsp;collections<br>
of&nbsp;constraints<br>
&nbsp;<br>
Fields:<br>
&nbsp;&nbsp;&nbsp;&nbsp;composite&nbsp;(Composite):&nbsp;A&nbsp;reference&nbsp;to&nbsp;the&nbsp;composite&nbsp;that&nbsp;holds&nbsp;the&nbsp;images&nbsp;of&nbsp;this&nbsp;constraint<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;index1&nbsp;(int):&nbsp;The&nbsp;index&nbsp;in&nbsp;the&nbsp;composite&nbsp;to&nbsp;the&nbsp;first&nbsp;image.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This&nbsp;index&nbsp;will&nbsp;always&nbsp;be&nbsp;less&nbsp;than&nbsp;index2,&nbsp;if&nbsp;index1&nbsp;&gt;&nbsp;index2&nbsp;then<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;constraint&nbsp;should&nbsp;have&nbsp;been&nbsp;created&nbsp;swapping&nbsp;index1&nbsp;and&nbsp;index2<br>
&nbsp;&nbsp;&nbsp;&nbsp;index2&nbsp;(int):&nbsp;The&nbsp;index&nbsp;in&nbsp;the&nbsp;composite&nbsp;to&nbsp;the&nbsp;second&nbsp;image<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;dx&nbsp;(int):&nbsp;X&nbsp;coordinate&nbsp;offset&nbsp;from&nbsp;image1&nbsp;to&nbsp;image2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This&nbsp;offset&nbsp;is&nbsp;measured&nbsp;from&nbsp;the&nbsp;pixel&nbsp;at&nbsp;0,0&nbsp;of&nbsp;image1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to&nbsp;the&nbsp;pixel&nbsp;at&nbsp;0,0&nbsp;of&nbsp;image2,&nbsp;or&nbsp;put&nbsp;another&nbsp;way&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offset&nbsp;is&nbsp;measured&nbsp;from&nbsp;the&nbsp;position&nbsp;of&nbsp;the&nbsp;box&nbsp;of&nbsp;the&nbsp;first&nbsp;image<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to&nbsp;the&nbsp;position&nbsp;of&nbsp;the&nbsp;box&nbsp;of&nbsp;the&nbsp;second&nbsp;image<br>
&nbsp;&nbsp;&nbsp;&nbsp;dy&nbsp;(int):&nbsp;Y&nbsp;coordinate&nbsp;offset&nbsp;from&nbsp;image1&nbsp;to&nbsp;image2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Measured&nbsp;the&nbsp;same&nbsp;way&nbsp;as&nbsp;dx,&nbsp;from&nbsp;the&nbsp;0,0&nbsp;pixel&nbsp;in&nbsp;image1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to&nbsp;the&nbsp;0,0&nbsp;pixel&nbsp;in&nbsp;image2,&nbsp;or&nbsp;from&nbsp;box1.position&nbsp;to&nbsp;box2.position<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;score&nbsp;(float):&nbsp;A&nbsp;value&nbsp;that&nbsp;relatively&nbsp;scores&nbsp;how&nbsp;well&nbsp;the&nbsp;alignment&nbsp;is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This&nbsp;score&nbsp;is&nbsp;generated&nbsp;by&nbsp;the&nbsp;alignment&nbsp;algorithm,&nbsp;to&nbsp;allow&nbsp;for&nbsp;filtering<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;weighting&nbsp;of&nbsp;constraints&nbsp;based&nbsp;on&nbsp;it.&nbsp;Constraints&nbsp;calculated<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from&nbsp;existing&nbsp;image&nbsp;positions&nbsp;will&nbsp;have&nbsp;a&nbsp;score&nbsp;of&nbsp;None<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;error&nbsp;(int):&nbsp;The&nbsp;uncertanty&nbsp;of&nbsp;the&nbsp;specified&nbsp;alignment<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This&nbsp;error&nbsp;value&nbsp;is&nbsp;treated&nbsp;as&nbsp;an&nbsp;uncertanty,&nbsp;saying&nbsp;the&nbsp;true&nbsp;alignment<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is&nbsp;equal&nbsp;to&nbsp;(dx&nbsp;±&nbsp;error,&nbsp;dy&nbsp;±&nbsp;error).&nbsp;This&nbsp;is&nbsp;typically&nbsp;zero<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unless&nbsp;the&nbsp;images&nbsp;were&nbsp;downscaled,&nbsp;and&nbsp;the&nbsp;uncertanty&nbsp;of&nbsp;original<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image&nbsp;positions&nbsp;can&nbsp;be&nbsp;specified&nbsp;by&nbsp;the&nbsp;user.&nbsp;When&nbsp;calculating&nbsp;new&nbsp;constraints<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;only&nbsp;offsets&nbsp;that&nbsp;fall&nbsp;within&nbsp;these&nbsp;bounds&nbsp;are&nbsp;considered,&nbsp;see&nbsp;section1&nbsp;and&nbsp;section2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;more&nbsp;information&nbsp;on&nbsp;how<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="Constraint-__init__"><strong>__init__</strong></a>(self, composite, index1=None, index2=None, dx=None, dy=None, score=None, error=None, type=&lt;ConstraintType.NORMAL: 'normal'&gt;)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="Constraint-__repr__"><strong>__repr__</strong></a>(self)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="Constraint-__str__"><strong>__str__</strong></a>(self)</dt><dd><tt>Return&nbsp;str(self).</tt></dd></dl>

<dl><dt><a name="Constraint-calculate"><strong>calculate</strong></a>(self, aligner=None, executor=None)</dt><dd><tt>Calculates&nbsp;a&nbsp;new&nbsp;constraint&nbsp;using&nbsp;the&nbsp;specified&nbsp;alignment&nbsp;algorithm.<br>
More&nbsp;information&nbsp;on&nbsp;how&nbsp;alignment&nbsp;is&nbsp;performed&nbsp;can&nbsp;be&nbsp;found&nbsp;at&nbsp;constitch.alignment</tt></dd></dl>

<dl><dt><a name="Constraint-new"><strong>new</strong></a>(self, dx=None, dy=None, score=None, error=None, type=None)</dt><dd><tt>Creates&nbsp;a&nbsp;new&nbsp;constraint&nbsp;between&nbsp;the&nbsp;images&nbsp;of&nbsp;this&nbsp;one.&nbsp;Normally&nbsp;used<br>
by&nbsp;alignment&nbsp;algorithms&nbsp;when&nbsp;they&nbsp;calculate&nbsp;a<br>
new&nbsp;constraint<br>
&nbsp;<br>
Params:<br>
&nbsp;&nbsp;&nbsp;&nbsp;dx,&nbsp;dy,&nbsp;score,&nbsp;error,&nbsp;type:&nbsp;See&nbsp;docs&nbsp;for&nbsp;<a href="#Constraint">Constraint</a>.<a href="#Constraint-__init__">__init__</a>()</tt></dd></dl>

<dl><dt><a name="Constraint-new_rescaled"><strong>new_rescaled</strong></a>(self, dx=None, dy=None, score=None, error=None, type=None)</dt><dd><tt>Creates&nbsp;a&nbsp;new&nbsp;constraint,&nbsp;similar&nbsp;to&nbsp;<a href="#Constraint">Constraint</a>.new.&nbsp;This&nbsp;method&nbsp;is&nbsp;used&nbsp;when<br>
the&nbsp;new&nbsp;constraint&nbsp;was&nbsp;calculated&nbsp;using&nbsp;<a href="#Constraint">Constraint</a>.resized_image1&nbsp;and&nbsp;<a href="#Constraint">Constraint</a>.resized_image2,<br>
normally&nbsp;when&nbsp;aligning&nbsp;in&nbsp;an&nbsp;<a href="#Aligner">Aligner</a>.&nbsp;This&nbsp;means&nbsp;that&nbsp;dx&nbsp;and&nbsp;dy&nbsp;are&nbsp;expected&nbsp;to&nbsp;be<br>
the&nbsp;offsets&nbsp;in&nbsp;these&nbsp;resized&nbsp;images,&nbsp;and&nbsp;they&nbsp;are&nbsp;converted&nbsp;into&nbsp;an&nbsp;offset&nbsp;in&nbsp;the&nbsp;original&nbsp;image,<br>
taking&nbsp;into&nbsp;account&nbsp;the&nbsp;amount&nbsp;each&nbsp;image&nbsp;has&nbsp;been&nbsp;resized.&nbsp;The&nbsp;error&nbsp;is&nbsp;also&nbsp;adjusted,&nbsp;eg<br>
if&nbsp;the&nbsp;alignment&nbsp;in&nbsp;the&nbsp;rescaled&nbsp;images&nbsp;is&nbsp;accurate&nbsp;to&nbsp;8&nbsp;pixels&nbsp;but&nbsp;the&nbsp;images&nbsp;were&nbsp;upscaled&nbsp;by<br>
4&nbsp;pixels,&nbsp;the&nbsp;true&nbsp;error&nbsp;would&nbsp;be&nbsp;2</tt></dd></dl>

<dl><dt><a name="Constraint-new_section"><strong>new_section</strong></a>(self, dx=None, dy=None, score=None, error=None, type=None)</dt><dd><tt>Creates&nbsp;a&nbsp;new&nbsp;constraint,&nbsp;similar&nbsp;to&nbsp;<a href="#Constraint">Constraint</a>.new.&nbsp;This&nbsp;method&nbsp;is&nbsp;used&nbsp;when<br>
the&nbsp;new&nbsp;constraint&nbsp;was&nbsp;calculated&nbsp;using&nbsp;<a href="#Constraint">Constraint</a>.section1&nbsp;and&nbsp;<a href="#Constraint">Constraint</a>.section2,<br>
normally&nbsp;when&nbsp;aligning&nbsp;in&nbsp;an&nbsp;<a href="#Aligner">Aligner</a>.&nbsp;This&nbsp;means&nbsp;that&nbsp;dx,&nbsp;dy,&nbsp;and&nbsp;error&nbsp;are&nbsp;expected&nbsp;to&nbsp;be<br>
relative&nbsp;to&nbsp;the&nbsp;coordinate&nbsp;space&nbsp;of&nbsp;the&nbsp;sections,&nbsp;and&nbsp;are&nbsp;converted&nbsp;into&nbsp;an&nbsp;offset&nbsp;and&nbsp;error&nbsp;for&nbsp;the&nbsp;whole&nbsp;image,<br>
taking&nbsp;into&nbsp;account&nbsp;the&nbsp;bounds&nbsp;of&nbsp;the&nbsp;sections&nbsp;and&nbsp;the&nbsp;amount&nbsp;each&nbsp;image&nbsp;has&nbsp;been<br>
resized</tt></dd></dl>

<dl><dt><a name="Constraint-to_obj"><strong>to_obj</strong></a>(self)</dt></dl>

<hr>
Readonly properties defined here:<br>
<dl><dt><strong>box1</strong></dt>
<dd><tt>Retrieves&nbsp;the&nbsp;box&nbsp;of&nbsp;image1&nbsp;from&nbsp;the&nbsp;composite,<br>
equivalent&nbsp;to&nbsp;self.<strong>composite</strong>.boxes[self.<strong>index1</strong>]</tt></dd>
</dl>
<dl><dt><strong>box2</strong></dt>
<dd><tt>Retrieves&nbsp;the&nbsp;box&nbsp;of&nbsp;image2&nbsp;from&nbsp;the&nbsp;composite,<br>
equivalent&nbsp;to&nbsp;self.<strong>composite</strong>.boxes[self.<strong>index2</strong>]</tt></dd>
</dl>
<dl><dt><strong>difference</strong></dt>
<dd><tt>The&nbsp;difference&nbsp;between&nbsp;the&nbsp;offset&nbsp;specified&nbsp;in&nbsp;this&nbsp;constraint&nbsp;and&nbsp;the<br>
difference&nbsp;in&nbsp;positions&nbsp;of&nbsp;the&nbsp;images&nbsp;currently,&nbsp;from&nbsp;self.<strong>box1</strong>&nbsp;and&nbsp;self.<strong>box2</strong>.<br>
If&nbsp;this&nbsp;constraint&nbsp;was&nbsp;calculated&nbsp;using&nbsp;an&nbsp;alignment&nbsp;algorithm&nbsp;this&nbsp;is&nbsp;the<br>
correction&nbsp;the&nbsp;alignment&nbsp;algorithm&nbsp;applied,&nbsp;and&nbsp;if&nbsp;this&nbsp;is&nbsp;after&nbsp;the&nbsp;global<br>
positions&nbsp;of&nbsp;the&nbsp;images&nbsp;have&nbsp;been&nbsp;solved&nbsp;then&nbsp;this&nbsp;is&nbsp;the&nbsp;error&nbsp;present&nbsp;when<br>
solving&nbsp;for&nbsp;the&nbsp;positions</tt></dd>
</dl>
<dl><dt><strong>image1</strong></dt>
<dd><tt>Retrieves&nbsp;the&nbsp;image1&nbsp;from&nbsp;the&nbsp;composite,<br>
equivalent&nbsp;to&nbsp;self.<strong>composite</strong>.images[self.<strong>index1</strong>]</tt></dd>
</dl>
<dl><dt><strong>image2</strong></dt>
<dd><tt>Retrieves&nbsp;the&nbsp;image2&nbsp;from&nbsp;the&nbsp;composite,<br>
equivalent&nbsp;to&nbsp;self.<strong>composite</strong>.images[self.<strong>index2</strong>]</tt></dd>
</dl>
<dl><dt><strong>implicit</strong></dt>
<dd><tt>Whether&nbsp;or&nbsp;not&nbsp;this&nbsp;constraint&nbsp;is&nbsp;implicit,&nbsp;meaning&nbsp;it&nbsp;was&nbsp;calculated<br>
from&nbsp;existing&nbsp;image&nbsp;positions&nbsp;and&nbsp;was&nbsp;not&nbsp;calculated&nbsp;using&nbsp;an&nbsp;alignment<br>
algorithm</tt></dd>
</dl>
<dl><dt><strong>length</strong></dt>
<dd><tt>The&nbsp;length&nbsp;of&nbsp;the&nbsp;offset&nbsp;between&nbsp;images,&nbsp;sqrt(dx^2&nbsp;+&nbsp;dy^2)</tt></dd>
</dl>
<dl><dt><strong>modeled</strong></dt>
</dl>
<dl><dt><strong>overlap</strong></dt>
<dd><tt>The&nbsp;overlap&nbsp;of&nbsp;the&nbsp;two&nbsp;images,&nbsp;in&nbsp;total&nbsp;number&nbsp;of&nbsp;pixels.&nbsp;If&nbsp;the&nbsp;images<br>
don't&nbsp;overlap,&nbsp;it&nbsp;will&nbsp;be&nbsp;negative</tt></dd>
</dl>
<dl><dt><strong>overlap_ratio</strong></dt>
<dd><tt>The&nbsp;overlap&nbsp;of&nbsp;the&nbsp;two&nbsp;images,&nbsp;as&nbsp;a&nbsp;ratio&nbsp;of&nbsp;the&nbsp;number&nbsp;of&nbsp;pixels&nbsp;overlapping<br>
over&nbsp;the&nbsp;maximum&nbsp;possible&nbsp;number&nbsp;of&nbsp;pixels&nbsp;overlapping</tt></dd>
</dl>
<dl><dt><strong>overlap_ratio_x</strong></dt>
<dd><tt>The&nbsp;overlap&nbsp;of&nbsp;the&nbsp;two&nbsp;images&nbsp;across&nbsp;the&nbsp;x&nbsp;axis,&nbsp;as&nbsp;a&nbsp;ratio&nbsp;of&nbsp;the&nbsp;image&nbsp;size.<br>
If&nbsp;the&nbsp;images&nbsp;are&nbsp;different&nbsp;sizes&nbsp;it&nbsp;is&nbsp;a&nbsp;ratio&nbsp;with&nbsp;the&nbsp;smaller&nbsp;images&nbsp;size.</tt></dd>
</dl>
<dl><dt><strong>overlap_ratio_y</strong></dt>
<dd><tt>The&nbsp;overlap&nbsp;of&nbsp;the&nbsp;two&nbsp;images&nbsp;across&nbsp;the&nbsp;y&nbsp;axis,&nbsp;as&nbsp;a&nbsp;ratio&nbsp;of&nbsp;the&nbsp;image&nbsp;size.<br>
If&nbsp;the&nbsp;images&nbsp;are&nbsp;different&nbsp;sizes&nbsp;it&nbsp;is&nbsp;a&nbsp;ratio&nbsp;with&nbsp;the&nbsp;smaller&nbsp;images&nbsp;size.</tt></dd>
</dl>
<dl><dt><strong>overlap_x</strong></dt>
<dd><tt>The&nbsp;overlap&nbsp;of&nbsp;the&nbsp;two&nbsp;images&nbsp;across&nbsp;the&nbsp;x&nbsp;axis,&nbsp;in&nbsp;pixels</tt></dd>
</dl>
<dl><dt><strong>overlap_y</strong></dt>
<dd><tt>The&nbsp;overlap&nbsp;of&nbsp;the&nbsp;two&nbsp;images&nbsp;across&nbsp;the&nbsp;y&nbsp;axis,&nbsp;in&nbsp;pixels</tt></dd>
</dl>
<dl><dt><strong>pair</strong></dt>
<dd><tt>The&nbsp;two&nbsp;indices&nbsp;of&nbsp;the&nbsp;images&nbsp;in&nbsp;the&nbsp;composite&nbsp;as&nbsp;a&nbsp;tuple</tt></dd>
</dl>
<dl><dt><strong>pixel_scale_ratio</strong></dt>
<dd><tt>The&nbsp;difference&nbsp;in&nbsp;pixel&nbsp;scale&nbsp;between&nbsp;image1&nbsp;and&nbsp;image2.&nbsp;For&nbsp;example<br>
if&nbsp;image2&nbsp;was&nbsp;taken&nbsp;with&nbsp;2x&nbsp;the&nbsp;magnification&nbsp;and&nbsp;thus&nbsp;each&nbsp;pixel&nbsp;is<br>
half&nbsp;the&nbsp;size&nbsp;of&nbsp;each&nbsp;pixel&nbsp;in&nbsp;image1,&nbsp;the&nbsp;scale&nbsp;ratio&nbsp;would&nbsp;be&nbsp;2&nbsp;/&nbsp;1<br>
as&nbsp;image2&nbsp;would&nbsp;need&nbsp;to&nbsp;be&nbsp;scaled&nbsp;up&nbsp;by&nbsp;2&nbsp;to&nbsp;have&nbsp;the&nbsp;same&nbsp;pixel&nbsp;size.<br>
The&nbsp;ratio&nbsp;is&nbsp;returned&nbsp;as&nbsp;a&nbsp;fractions.Fraction&nbsp;for&nbsp;the&nbsp;x&nbsp;and&nbsp;y&nbsp;axes.</tt></dd>
</dl>
<dl><dt><strong>resized_image1</strong></dt>
<dd><tt>Retrieves&nbsp;the&nbsp;first&nbsp;image&nbsp;of&nbsp;the&nbsp;constraint,&nbsp;resizing&nbsp;it&nbsp;so&nbsp;that<br>
the&nbsp;scale&nbsp;of&nbsp;pixels&nbsp;between&nbsp;image1&nbsp;and&nbsp;image2&nbsp;is&nbsp;the&nbsp;same.<br>
This&nbsp;may&nbsp;require&nbsp;computing&nbsp;the&nbsp;resized&nbsp;image,&nbsp;but&nbsp;it&nbsp;will&nbsp;be&nbsp;cached<br>
in&nbsp;the&nbsp;composite&nbsp;and&nbsp;any&nbsp;subsequent&nbsp;calls&nbsp;will&nbsp;not&nbsp;require&nbsp;any&nbsp;calculation</tt></dd>
</dl>
<dl><dt><strong>resized_image2</strong></dt>
<dd><tt>Retrieves&nbsp;the&nbsp;first&nbsp;image&nbsp;of&nbsp;the&nbsp;constraint,&nbsp;resizing&nbsp;it&nbsp;so&nbsp;that<br>
the&nbsp;scale&nbsp;of&nbsp;pixels&nbsp;between&nbsp;image1&nbsp;and&nbsp;image2&nbsp;is&nbsp;the&nbsp;same.<br>
This&nbsp;may&nbsp;require&nbsp;computing&nbsp;the&nbsp;resized&nbsp;image,&nbsp;but&nbsp;it&nbsp;will&nbsp;be&nbsp;cached<br>
in&nbsp;the&nbsp;composite&nbsp;and&nbsp;any&nbsp;subsequent&nbsp;calls&nbsp;will&nbsp;not&nbsp;require&nbsp;any&nbsp;calculation</tt></dd>
</dl>
<dl><dt><strong>section1</strong></dt>
<dd><tt>Returns&nbsp;the&nbsp;section&nbsp;of&nbsp;image1&nbsp;relevant&nbsp;for&nbsp;alignment,&nbsp;that&nbsp;is&nbsp;the<br>
section&nbsp;of&nbsp;image1&nbsp;that&nbsp;overlaps&nbsp;with&nbsp;image2,&nbsp;expanded&nbsp;to&nbsp;include&nbsp;self.<strong>error</strong>,<br>
and&nbsp;resized&nbsp;so&nbsp;that&nbsp;both&nbsp;sections&nbsp;have&nbsp;the&nbsp;same&nbsp;pixel&nbsp;scale.<br>
If&nbsp;error&nbsp;is&nbsp;infinite&nbsp;or&nbsp;None&nbsp;this&nbsp;will&nbsp;be&nbsp;the&nbsp;same&nbsp;as&nbsp;self.<strong>resized_image1</strong>.<br>
Usually&nbsp;used&nbsp;by&nbsp;the&nbsp;alignment&nbsp;algorithm&nbsp;when&nbsp;calculating&nbsp;new&nbsp;constraints,<br>
see&nbsp;the&nbsp;docs&nbsp;for&nbsp;Aligner&nbsp;for&nbsp;more&nbsp;info</tt></dd>
</dl>
<dl><dt><strong>section1_bounds</strong></dt>
</dl>
<dl><dt><strong>section2</strong></dt>
<dd><tt>Returns&nbsp;the&nbsp;section&nbsp;of&nbsp;image2&nbsp;relevant&nbsp;for&nbsp;alignment,&nbsp;that&nbsp;is&nbsp;the<br>
section&nbsp;of&nbsp;image2&nbsp;that&nbsp;overlaps&nbsp;with&nbsp;image1,&nbsp;expanded&nbsp;to&nbsp;include&nbsp;self.<strong>error</strong>,<br>
and&nbsp;resized&nbsp;so&nbsp;that&nbsp;both&nbsp;sections&nbsp;have&nbsp;the&nbsp;same&nbsp;pixel&nbsp;scale.<br>
If&nbsp;error&nbsp;is&nbsp;infinite&nbsp;or&nbsp;None&nbsp;this&nbsp;will&nbsp;be&nbsp;the&nbsp;same&nbsp;as&nbsp;self.<strong>resized_image1</strong>.</tt></dd>
</dl>
<dl><dt><strong>section2_bounds</strong></dt>
</dl>
<dl><dt><strong>touching</strong></dt>
<dd><tt>True&nbsp;if&nbsp;the&nbsp;images&nbsp;are&nbsp;either&nbsp;overlapping&nbsp;(self.<strong>overlap</strong>&nbsp;&gt;&nbsp;0)&nbsp;or&nbsp;touching<br>
along&nbsp;the&nbsp;x&nbsp;or&nbsp;y&nbsp;axis&nbsp;(self.<strong>overlap_x</strong>&nbsp;&gt;&nbsp;0&nbsp;or&nbsp;self.<strong>overlap_y</strong>&nbsp;&gt;&nbsp;0)</tt></dd>
</dl>
<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="ConstraintFilter">class <strong>ConstraintFilter</strong></a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#ConstraintFilter">ConstraintFilter</a>(obj=None,&nbsp;**kwargs)<br>
&nbsp;<br>
A&nbsp;class&nbsp;that&nbsp;represents&nbsp;a&nbsp;filter&nbsp;on&nbsp;constraints.&nbsp;Can&nbsp;be&nbsp;a&nbsp;threshold<br>
on&nbsp;a&nbsp;attribute&nbsp;of&nbsp;constraints,&nbsp;eg&nbsp;<a href="#ConstraintFilter">ConstraintFilter</a>(min_score=0.5),<br>
a&nbsp;required&nbsp;value&nbsp;or&nbsp;constraint&nbsp;type,&nbsp;eg&nbsp;<a href="#ConstraintFilter">ConstraintFilter</a>(touching=True,&nbsp;implicit=True),<br>
or&nbsp;a&nbsp;custom&nbsp;function&nbsp;that&nbsp;returns&nbsp;a&nbsp;bool,&nbsp;eg&nbsp;<a href="#ConstraintFilter">ConstraintFilter</a>(lambda&nbsp;const:&nbsp;const.box1.position[0]&nbsp;&lt;&nbsp;5000)<br>
&nbsp;<br>
Filters&nbsp;can&nbsp;be&nbsp;created&nbsp;and&nbsp;combined&nbsp;with&nbsp;&amp;&nbsp;or&nbsp;|&nbsp;and&nbsp;passed&nbsp;to&nbsp;<a href="#ConstraintSet">ConstraintSet</a>.filter()&nbsp;to&nbsp;select&nbsp;for<br>
specific&nbsp;constraints.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="ConstraintFilter-__and__"><strong>__and__</strong></a>(self, other)</dt><dd><tt>Combines&nbsp;two&nbsp;filters,&nbsp;creating&nbsp;a&nbsp;new&nbsp;filter&nbsp;that&nbsp;evaluates<br>
to&nbsp;True&nbsp;when&nbsp;both&nbsp;others&nbsp;evaluate&nbsp;to&nbsp;True</tt></dd></dl>

<dl><dt><a name="ConstraintFilter-__call__"><strong>__call__</strong></a>(self, constraint)</dt><dd><tt>Evaluates&nbsp;the&nbsp;filter&nbsp;on&nbsp;a&nbsp;constraint.<br>
Returns&nbsp;whether&nbsp;or&nbsp;not&nbsp;the&nbsp;constraint&nbsp;should&nbsp;be&nbsp;kept.</tt></dd></dl>

<dl><dt><a name="ConstraintFilter-__init__"><strong>__init__</strong></a>(self, obj=None, **kwargs)</dt><dd><tt>A&nbsp;filter&nbsp;can&nbsp;be&nbsp;constructed&nbsp;in&nbsp;multiple&nbsp;ways:<br>
&nbsp;<br>
<a href="#ConstraintFilter">ConstraintFilter</a>(params)<br>
<a href="#ConstraintFilter">ConstraintFilter</a>(**kwargs)<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Constructing&nbsp;with&nbsp;a&nbsp;dictionary&nbsp;of&nbsp;parameters.&nbsp;Each&nbsp;entry&nbsp;in&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;dictionary&nbsp;or&nbsp;keyword&nbsp;parameter&nbsp;must&nbsp;be&nbsp;an&nbsp;attribute&nbsp;of&nbsp;a&nbsp;<a href="#Constraint">Constraint</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;instance,&nbsp;optionally&nbsp;prepended&nbsp;with&nbsp;min_&nbsp;or&nbsp;max_.<br>
&nbsp;&nbsp;&nbsp;&nbsp;When&nbsp;filtering,&nbsp;the&nbsp;specified&nbsp;attribute&nbsp;will&nbsp;be&nbsp;retrieved&nbsp;from&nbsp;each&nbsp;constraint<br>
&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;compared&nbsp;to&nbsp;the&nbsp;value&nbsp;passed&nbsp;here.&nbsp;If&nbsp;prepended&nbsp;with&nbsp;min_&nbsp;values&nbsp;greater&nbsp;or&nbsp;equal<br>
&nbsp;&nbsp;&nbsp;&nbsp;will&nbsp;be&nbsp;kept&nbsp;and&nbsp;if&nbsp;prepended&nbsp;with&nbsp;max_&nbsp;values&nbsp;less&nbsp;than&nbsp;or&nbsp;equal&nbsp;will&nbsp;be&nbsp;kept,<br>
&nbsp;&nbsp;&nbsp;&nbsp;otherwise&nbsp;only&nbsp;values&nbsp;that&nbsp;are&nbsp;equal&nbsp;are&nbsp;kept.<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;For&nbsp;example,&nbsp;the&nbsp;filter&nbsp;<a href="#ConstraintFilter">ConstraintFilter</a>(min_score=0.5)&nbsp;will&nbsp;keep&nbsp;constrains&nbsp;where<br>
&nbsp;&nbsp;&nbsp;&nbsp;constraint.score&nbsp;&gt;=&nbsp;0.5&nbsp;is&nbsp;True.<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;When&nbsp;multiple&nbsp;parameters&nbsp;are&nbsp;specified,&nbsp;only&nbsp;constraints&nbsp;that&nbsp;match&nbsp;all&nbsp;parameters<br>
&nbsp;&nbsp;&nbsp;&nbsp;will&nbsp;be&nbsp;kept.&nbsp;If&nbsp;you&nbsp;want&nbsp;to&nbsp;match&nbsp;either&nbsp;parameter,&nbsp;create&nbsp;multiple&nbsp;filters&nbsp;and&nbsp;combine<br>
&nbsp;&nbsp;&nbsp;&nbsp;them,&nbsp;eg&nbsp;<a href="#ConstraintFilter">ConstraintFilter</a>(touching=True)&nbsp;|&nbsp;<a href="#ConstraintFilter">ConstraintFilter</a>(min_score=0.5)<br>
&nbsp;<br>
<a href="#ConstraintFilter">ConstraintFilter</a>(func)<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Constructing&nbsp;from&nbsp;a&nbsp;function.&nbsp;The&nbsp;passed&nbsp;function&nbsp;is&nbsp;evaluated&nbsp;for&nbsp;each&nbsp;constraint,<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;True&nbsp;the&nbsp;constraint&nbsp;is&nbsp;kept.&nbsp;This&nbsp;has&nbsp;the&nbsp;same&nbsp;behaviour&nbsp;as&nbsp;the&nbsp;builtin&nbsp;filter()</tt></dd></dl>

<dl><dt><a name="ConstraintFilter-__or__"><strong>__or__</strong></a>(self, other)</dt><dd><tt>Combines&nbsp;two&nbsp;filters,&nbsp;creating&nbsp;a&nbsp;new&nbsp;filter&nbsp;that&nbsp;evaluates<br>
to&nbsp;True&nbsp;when&nbsp;either&nbsp;other&nbsp;filters&nbsp;evaluate&nbsp;to&nbsp;True</tt></dd></dl>

<dl><dt><a name="ConstraintFilter-__str__"><strong>__str__</strong></a>(self)</dt><dd><tt>Return&nbsp;str(self).</tt></dd></dl>

<dl><dt><a name="ConstraintFilter-alwaystrue"><strong>alwaystrue</strong></a>(self)</dt></dl>

<dl><dt><a name="ConstraintFilter-fromdict"><strong>fromdict</strong></a>(self, params)</dt></dl>

<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="ConstraintSet">class <strong>ConstraintSet</strong></a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#ConstraintSet">ConstraintSet</a>(constraints=None)<br>
&nbsp;<br>
A&nbsp;class&nbsp;that&nbsp;stores&nbsp;a&nbsp;set&nbsp;of&nbsp;constraints<br>
&nbsp;<br>
Many&nbsp;important&nbsp;algorithms&nbsp;when&nbsp;stitching&nbsp;revolve&nbsp;around&nbsp;manipulating<br>
sets&nbsp;of&nbsp;constraints,&nbsp;thus&nbsp;we&nbsp;have&nbsp;the&nbsp;class&nbsp;<a href="#ConstraintSet">ConstraintSet</a>&nbsp;to&nbsp;represent<br>
collections&nbsp;of&nbsp;Constraints&nbsp;and&nbsp;filter/manipulate&nbsp;them.&nbsp;A&nbsp;<a href="#ConstraintSet">ConstraintSet</a><br>
behaves&nbsp;mostly&nbsp;like&nbsp;a&nbsp;dictionary&nbsp;mapping&nbsp;pairs&nbsp;of&nbsp;images&nbsp;to&nbsp;Constraints.<br>
&nbsp;<br>
ConstraintSets&nbsp;are&nbsp;normally&nbsp;created&nbsp;from&nbsp;<a href="#CompositeImage">CompositeImage</a>.constraints<br>
or&nbsp;<a href="#ConstraintSet">ConstraintSet</a>.calculate,&nbsp;but&nbsp;they&nbsp;can&nbsp;be&nbsp;instantiated&nbsp;with&nbsp;any<br>
sequence&nbsp;of&nbsp;Constraints<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="ConstraintSet-__contains__"><strong>__contains__</strong></a>(self, obj)</dt><dd><tt>Tests&nbsp;if&nbsp;a&nbsp;<a href="#Constraint">Constraint</a>&nbsp;or&nbsp;a&nbsp;pair&nbsp;is&nbsp;contained</tt></dd></dl>

<dl><dt><a name="ConstraintSet-__getattr__"><strong>__getattr__</strong></a>(self, name)</dt><dd><tt>Some&nbsp;attributes&nbsp;of&nbsp;<a href="#Constraint">Constraint</a>&nbsp;can&nbsp;be&nbsp;accessed&nbsp;from&nbsp;a&nbsp;<a href="#ConstraintSet">ConstraintSet</a>,&nbsp;returned&nbsp;as&nbsp;a&nbsp;numpy<br>
array&nbsp;of&nbsp;the&nbsp;values&nbsp;for&nbsp;all&nbsp;constraints,&nbsp;in&nbsp;the&nbsp;order&nbsp;of&nbsp;self.<a href="#ConstraintSet-keys">keys</a>()</tt></dd></dl>

<dl><dt><a name="ConstraintSet-__getitem__"><strong>__getitem__</strong></a>(self, pair)</dt></dl>

<dl><dt><a name="ConstraintSet-__init__"><strong>__init__</strong></a>(self, constraints=None)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="ConstraintSet-__iter__"><strong>__iter__</strong></a>(self)</dt><dd><tt>Iterates&nbsp;through&nbsp;all&nbsp;constraints&nbsp;in&nbsp;this&nbsp;set</tt></dd></dl>

<dl><dt><a name="ConstraintSet-__len__"><strong>__len__</strong></a>(self)</dt></dl>

<dl><dt><a name="ConstraintSet-add"><strong>add</strong></a>(self, other)</dt><dd><tt>Add&nbsp;constraints&nbsp;to&nbsp;this&nbsp;set<br>
&nbsp;<br>
If&nbsp;a&nbsp;constraint&nbsp;between&nbsp;the&nbsp;same&nbsp;images&nbsp;is&nbsp;already&nbsp;present,&nbsp;the&nbsp;constraint<br>
with&nbsp;the&nbsp;lower&nbsp;error&nbsp;is&nbsp;kept&nbsp;and&nbsp;the&nbsp;other&nbsp;is&nbsp;removed.<br>
In&nbsp;the&nbsp;case&nbsp;of&nbsp;equal&nbsp;errors&nbsp;the&nbsp;new&nbsp;constraint&nbsp;is&nbsp;kept<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;other&nbsp;(<a href="#Constraint">Constraint</a>&nbsp;or&nbsp;sequence&nbsp;of&nbsp;Constraints):&nbsp;<a href="#Constraint">Constraint</a>&nbsp;or&nbsp;Constraints&nbsp;to&nbsp;add<br>
&nbsp;<br>
Raises:<br>
&nbsp;&nbsp;&nbsp;&nbsp;ValueError:&nbsp;The&nbsp;constraint(s)&nbsp;to&nbsp;be&nbsp;added&nbsp;are&nbsp;from&nbsp;a&nbsp;different&nbsp;<a href="#CompositeImage">CompositeImage</a></tt></dd></dl>

<dl><dt><a name="ConstraintSet-calculate"><strong>calculate</strong></a>(self, aligner=None, executor=None)</dt><dd><tt>Calculates&nbsp;new&nbsp;constraints&nbsp;using&nbsp;an&nbsp;alignment&nbsp;algorithm<br>
&nbsp;<br>
For&nbsp;every&nbsp;constraint&nbsp;the&nbsp;provided&nbsp;aligner&nbsp;is&nbsp;invoked&nbsp;to&nbsp;calculate<br>
a&nbsp;new&nbsp;constraint.&nbsp;See&nbsp;constitch.alignment&nbsp;for&nbsp;more&nbsp;information&nbsp;on<br>
alignment.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;aligner&nbsp;(constitch.<a href="#Aligner">Aligner</a>):&nbsp;default&nbsp;self.<strong>composite</strong>.aligner<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;aligner&nbsp;that&nbsp;is&nbsp;used&nbsp;to&nbsp;calculate&nbsp;the&nbsp;new&nbsp;constraints<br>
&nbsp;&nbsp;&nbsp;&nbsp;executor&nbsp;(concurrent.futures.Executor):&nbsp;default&nbsp;self.<strong>composite</strong>.executor<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;thread&nbsp;or&nbsp;process&nbsp;pool&nbsp;instance&nbsp;to&nbsp;parallelize&nbsp;the&nbsp;computation,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;as&nbsp;some&nbsp;aligners&nbsp;can&nbsp;be&nbsp;quite&nbsp;slow</tt></dd></dl>

<dl><dt><a name="ConstraintSet-debug"><strong>debug</strong></a>(self, *args, **kwargs)</dt><dd><tt>A&nbsp;shorthand&nbsp;for&nbsp;self.<strong>composite</strong>.debug</tt></dd></dl>

<dl><dt><a name="ConstraintSet-filter"><strong>filter</strong></a>(self, obj=None, limit=None, random=False, sorted_by=None, **kwargs)</dt><dd><tt>Returns&nbsp;a&nbsp;new&nbsp;<a href="#ConstraintSet">ConstraintSet</a>&nbsp;with&nbsp;only&nbsp;constraints&nbsp;that&nbsp;are<br>
matching&nbsp;the&nbsp;specified&nbsp;filter.<br>
&nbsp;<br>
Either&nbsp;a&nbsp;<a href="#ConstraintFilter">ConstraintFilter</a>&nbsp;instance&nbsp;can&nbsp;be&nbsp;passed&nbsp;in&nbsp;or&nbsp;an&nbsp;<a href="builtins.html#object">object</a>&nbsp;that<br>
can&nbsp;be&nbsp;converted&nbsp;into&nbsp;a&nbsp;filter,&nbsp;ie&nbsp;a&nbsp;dictionary&nbsp;or&nbsp;a&nbsp;set&nbsp;of&nbsp;keyword&nbsp;arguments.<br>
See&nbsp;<a href="#ConstraintFilter">ConstraintFilter</a>&nbsp;for&nbsp;the&nbsp;full&nbsp;documentation&nbsp;on&nbsp;creating&nbsp;a&nbsp;filter.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;obj:&nbsp;The&nbsp;filter&nbsp;or&nbsp;<a href="builtins.html#object">object</a>&nbsp;to&nbsp;be&nbsp;converted&nbsp;into&nbsp;a&nbsp;filter.&nbsp;Can&nbsp;be&nbsp;many&nbsp;types:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;it&nbsp;is&nbsp;a&nbsp;<a href="#ConstraintFilter">ConstraintFilter</a>&nbsp;or&nbsp;a&nbsp;callable&nbsp;it&nbsp;is&nbsp;applied&nbsp;as&nbsp;the&nbsp;filter<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;it&nbsp;is&nbsp;a&nbsp;numpy&nbsp;bool&nbsp;array,&nbsp;it&nbsp;is&nbsp;used&nbsp;to&nbsp;filter&nbsp;constraint,&nbsp;mapping&nbsp;with<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;order&nbsp;of&nbsp;self.<strong>constraints</strong><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;it&nbsp;is&nbsp;a&nbsp;set&nbsp;or&nbsp;list&nbsp;of&nbsp;pairs&nbsp;of&nbsp;indices,&nbsp;only&nbsp;constraints&nbsp;for&nbsp;those&nbsp;pairs&nbsp;are&nbsp;kept<br>
&nbsp;&nbsp;&nbsp;&nbsp;limit&nbsp;(int):&nbsp;The&nbsp;maximum&nbsp;number&nbsp;of&nbsp;constraints&nbsp;returned<br>
&nbsp;&nbsp;&nbsp;&nbsp;random&nbsp;(bool):&nbsp;If&nbsp;true&nbsp;the&nbsp;constraints&nbsp;are&nbsp;shuffled<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Normally&nbsp;used&nbsp;in&nbsp;conjunction&nbsp;with&nbsp;the&nbsp;limit&nbsp;argument&nbsp;to&nbsp;select&nbsp;a&nbsp;random<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sample&nbsp;of&nbsp;the&nbsp;constraints<br>
&nbsp;&nbsp;&nbsp;&nbsp;sorted_by&nbsp;(function&nbsp;or&nbsp;str):&nbsp;key&nbsp;to&nbsp;sort&nbsp;constraints&nbsp;on<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Either&nbsp;a&nbsp;function&nbsp;that&nbsp;can&nbsp;be&nbsp;passed&nbsp;as&nbsp;a&nbsp;key&nbsp;to&nbsp;sorted()&nbsp;or&nbsp;a&nbsp;string<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;that&nbsp;is&nbsp;an&nbsp;attribute&nbsp;of&nbsp;a&nbsp;constraint.&nbsp;Used&nbsp;to&nbsp;sort&nbsp;the&nbsp;constraints,&nbsp;normally<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;used&nbsp;with&nbsp;the&nbsp;limit&nbsp;argument<br>
&nbsp;&nbsp;&nbsp;&nbsp;kwargs:&nbsp;Any&nbsp;keyword&nbsp;arguments&nbsp;are&nbsp;passed&nbsp;to&nbsp;a&nbsp;new&nbsp;<a href="#ConstraintFilter">ConstraintFilter</a>()&nbsp;constructor<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;applied&nbsp;as&nbsp;a&nbsp;filter<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;new&nbsp;<a href="#ConstraintSet">ConstraintSet</a>&nbsp;with&nbsp;the&nbsp;filtered&nbsp;Constraints</tt></dd></dl>

<dl><dt><a name="ConstraintSet-find"><strong>find</strong></a>(self, obj=None, **kwargs)</dt><dd><tt>Returns&nbsp;the&nbsp;first&nbsp;constraint&nbsp;to&nbsp;match&nbsp;a&nbsp;filter<br>
&nbsp;<br>
Uses&nbsp;the&nbsp;same&nbsp;interface&nbsp;as&nbsp;self.<strong>filter</strong>&nbsp;but&nbsp;returns&nbsp;the&nbsp;first<br>
constraint&nbsp;that&nbsp;matches&nbsp;the&nbsp;filter</tt></dd></dl>

<dl><dt><a name="ConstraintSet-fit_model"><strong>fit_model</strong></a>(self, model=None, outliers=False, random_state=12345)</dt><dd><tt>Fits&nbsp;a&nbsp;linear&nbsp;model&nbsp;to&nbsp;the&nbsp;constraints&nbsp;in&nbsp;this&nbsp;set<br>
&nbsp;<br>
This&nbsp;learns&nbsp;the&nbsp;motion&nbsp;of&nbsp;the&nbsp;microscope&nbsp;stage,&nbsp;which&nbsp;can&nbsp;be&nbsp;used&nbsp;to&nbsp;fill&nbsp;in<br>
constraints&nbsp;in&nbsp;areas&nbsp;where&nbsp;there&nbsp;are&nbsp;not&nbsp;enough&nbsp;features&nbsp;to&nbsp;align.<br>
&nbsp;<br>
The&nbsp;model&nbsp;is&nbsp;trained&nbsp;on&nbsp;the&nbsp;relation&nbsp;between&nbsp;the&nbsp;offset&nbsp;in&nbsp;image&nbsp;positions,<br>
that&nbsp;is&nbsp;box2.position&nbsp;-&nbsp;bos1.position,&nbsp;and&nbsp;the&nbsp;offset&nbsp;specified&nbsp;in&nbsp;dx&nbsp;and&nbsp;dy.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;model&nbsp;(sklearn&nbsp;base&nbsp;model):&nbsp;default&nbsp;constitch.<a href="#SimpleOffsetModel">SimpleOffsetModel</a>()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;linear&nbsp;model&nbsp;to&nbsp;train,&nbsp;it&nbsp;should&nbsp;be&nbsp;a&nbsp;sklearn&nbsp;model&nbsp;class,&nbsp;meaning<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it&nbsp;has&nbsp;a&nbsp;fit&nbsp;and&nbsp;predict&nbsp;method.&nbsp;The&nbsp;fit&nbsp;method&nbsp;is&nbsp;called<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with&nbsp;X&nbsp;as&nbsp;a&nbsp;4&nbsp;column&nbsp;matrix&nbsp;containing&nbsp;the&nbsp;x&nbsp;and&nbsp;y&nbsp;positions&nbsp;of&nbsp;image1&nbsp;and&nbsp;image2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;all&nbsp;constraints,&nbsp;and&nbsp;y&nbsp;as&nbsp;a&nbsp;2&nbsp;column&nbsp;matrix&nbsp;with&nbsp;dx&nbsp;and&nbsp;dy&nbsp;for&nbsp;all&nbsp;constraints<br>
&nbsp;&nbsp;&nbsp;&nbsp;outliers&nbsp;(bool):&nbsp;Whether&nbsp;to&nbsp;use&nbsp;an&nbsp;outlier&nbsp;resistant&nbsp;model<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;set&nbsp;to&nbsp;True&nbsp;the&nbsp;provided&nbsp;model&nbsp;is&nbsp;wrapped&nbsp;in&nbsp;sklearn.linear_model.RANSACRegressor,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;the&nbsp;inlier&nbsp;and&nbsp;outlier&nbsp;classifications&nbsp;are&nbsp;added&nbsp;onto&nbsp;the&nbsp;returned<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;as&nbsp;result.inliers&nbsp;and&nbsp;result.outliers.&nbsp;These&nbsp;are&nbsp;new&nbsp;ConstraintSets<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;containing&nbsp;only&nbsp;the&nbsp;inliers&nbsp;and&nbsp;outliers&nbsp;that&nbsp;the&nbsp;model&nbsp;classified<br>
&nbsp;&nbsp;&nbsp;&nbsp;random_state:&nbsp;the&nbsp;random&nbsp;state&nbsp;passed&nbsp;to&nbsp;RANSACRegressor&nbsp;when&nbsp;outliers=True<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;An&nbsp;<a href="#Aligner">Aligner</a>&nbsp;class&nbsp;that&nbsp;can&nbsp;be&nbsp;used&nbsp;to&nbsp;calculate&nbsp;new&nbsp;constraints,&nbsp;using<br>
&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;linear&nbsp;model&nbsp;fit&nbsp;here.</tt></dd></dl>

<dl><dt><a name="ConstraintSet-items"><strong>items</strong></a>(self)</dt></dl>

<dl><dt><a name="ConstraintSet-keys"><strong>keys</strong></a>(self)</dt></dl>

<dl><dt><a name="ConstraintSet-merge"><strong>merge</strong></a>(self, other, *others)</dt><dd><tt>Returns&nbsp;a&nbsp;new&nbsp;ConstaintSet&nbsp;with&nbsp;combined&nbsp;constraints&nbsp;from&nbsp;this&nbsp;and&nbsp;other&nbsp;sets<br>
&nbsp;<br>
As&nbsp;with&nbsp;<a href="#ConstraintSet-add">add</a>(),&nbsp;if&nbsp;constraints&nbsp;between&nbsp;the&nbsp;same&nbsp;image&nbsp;pair&nbsp;are&nbsp;present&nbsp;in&nbsp;both&nbsp;sets<br>
then&nbsp;the&nbsp;constraint&nbsp;with&nbsp;the&nbsp;lowest&nbsp;error&nbsp;is&nbsp;kept,&nbsp;with&nbsp;ties&nbsp;defaulting&nbsp;to&nbsp;constraints&nbsp;in&nbsp;the<br>
last&nbsp;passed&nbsp;in&nbsp;set<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;other&nbsp;(<a href="#Constraint">Constraint</a>&nbsp;or&nbsp;sequence&nbsp;of&nbsp;Constraints):&nbsp;<a href="#Constraint">Constraint</a>&nbsp;or&nbsp;Constraints&nbsp;to<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;merge&nbsp;with&nbsp;new&nbsp;set<br>
&nbsp;<br>
Raises:<br>
&nbsp;&nbsp;&nbsp;&nbsp;ValueError:&nbsp;The&nbsp;constraints&nbsp;to&nbsp;be&nbsp;merged&nbsp;are&nbsp;from&nbsp;a&nbsp;different&nbsp;ConstraintImage</tt></dd></dl>

<dl><dt><a name="ConstraintSet-neighborhood_difference"><strong>neighborhood_difference</strong></a>(self, constraint)</dt><dd><tt>A&nbsp;metric&nbsp;that&nbsp;measures&nbsp;how&nbsp;well&nbsp;this&nbsp;constraint&nbsp;matches&nbsp;the&nbsp;image<br>
positions,&nbsp;taking&nbsp;into&nbsp;account&nbsp;neighboring&nbsp;constraints.</tt></dd></dl>

<dl><dt><a name="ConstraintSet-neighboring"><strong>neighboring</strong></a>(self, constraint, depth=1)</dt><dd><tt>Returns&nbsp;a&nbsp;new&nbsp;<a href="#ConstraintSet">ConstraintSet</a>&nbsp;containing&nbsp;only&nbsp;constraints&nbsp;that<br>
are&nbsp;connected&nbsp;to&nbsp;an&nbsp;initial&nbsp;constraint&nbsp;or&nbsp;image<br>
&nbsp;<br>
The&nbsp;starting&nbsp;location&nbsp;is&nbsp;specified&nbsp;by&nbsp;passing&nbsp;either&nbsp;a&nbsp;constraint,&nbsp;a<br>
image&nbsp;index,&nbsp;or&nbsp;a&nbsp;sequence&nbsp;of&nbsp;either.&nbsp;Constraints&nbsp;are&nbsp;added&nbsp;by&nbsp;BFS&nbsp;to<br>
the&nbsp;requested&nbsp;depth.&nbsp;Any&nbsp;constraints&nbsp;provided&nbsp;as&nbsp;a&nbsp;starting&nbsp;location<br>
are&nbsp;not&nbsp;included&nbsp;in&nbsp;the&nbsp;resulting&nbsp;set</tt></dd></dl>

<dl><dt><a name="ConstraintSet-progress"><strong>progress</strong></a>(self, iter, **kwargs)</dt><dd><tt>A&nbsp;shorthand&nbsp;for&nbsp;self.<strong>composite</strong>.progress</tt></dd></dl>

<dl><dt><a name="ConstraintSet-remove"><strong>remove</strong></a>(self, other)</dt><dd><tt>Remove&nbsp;constraints&nbsp;from&nbsp;this&nbsp;set<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;other&nbsp;(<a href="#Constraint">Constraint</a>,&nbsp;(int,&nbsp;int)&nbsp;or&nbsp;sequence&nbsp;of&nbsp;either):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;constraints&nbsp;or&nbsp;pairs&nbsp;to&nbsp;be&nbsp;removed<br>
&nbsp;<br>
Raises:<br>
&nbsp;&nbsp;&nbsp;&nbsp;KeyError:&nbsp;The&nbsp;specified&nbsp;constraint&nbsp;does&nbsp;not&nbsp;exist</tt></dd></dl>

<dl><dt><a name="ConstraintSet-solve"><strong>solve</strong></a>(self, solver='mse', **kwargs)</dt><dd><tt>Solve&nbsp;the&nbsp;constraints&nbsp;to&nbsp;get&nbsp;a&nbsp;global&nbsp;position&nbsp;for&nbsp;each&nbsp;image<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;solver&nbsp;(constitch.<a href="#Solver">Solver</a>&nbsp;or&nbsp;str):&nbsp;default&nbsp;constitch.<a href="#LinearSolver">LinearSolver</a>()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;solver&nbsp;method&nbsp;that&nbsp;is&nbsp;used&nbsp;to&nbsp;combine&nbsp;the&nbsp;overconstrainted<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;system&nbsp;of&nbsp;constraints&nbsp;and&nbsp;optimize&nbsp;for&nbsp;the&nbsp;best&nbsp;global&nbsp;positions.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Options&nbsp;include&nbsp;'mse'&nbsp;for&nbsp;standard&nbsp;least&nbsp;squares&nbsp;solving,&nbsp;'mae'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;solving&nbsp;while&nbsp;minimizing&nbsp;mean&nbsp;absolute&nbsp;error,&nbsp;'huber'&nbsp;for<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;minimizing&nbsp;the&nbsp;huber&nbsp;loss,&nbsp;or&nbsp;any&nbsp;subclass&nbsp;of&nbsp;constitch.<a href="#Solver">Solver</a>.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;More&nbsp;info&nbsp;can&nbsp;be&nbsp;found&nbsp;in&nbsp;constitch.solving<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**kwargs:&nbsp;Arguments&nbsp;passed&nbsp;to&nbsp;the&nbsp;constructor&nbsp;of&nbsp;the&nbsp;solver.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Any&nbsp;arguments&nbsp;specified&nbsp;here&nbsp;are&nbsp;passed&nbsp;to&nbsp;the&nbsp;constructor<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;of&nbsp;the&nbsp;solver,&nbsp;for&nbsp;example&nbsp;if&nbsp;solver='huber'&nbsp;epsilon=5&nbsp;could<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;be&nbsp;included&nbsp;to&nbsp;change&nbsp;the&nbsp;default&nbsp;epsilon&nbsp;parameter&nbsp;for&nbsp;huber&nbsp;loss.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cannot&nbsp;be&nbsp;specified&nbsp;if&nbsp;solver&nbsp;is&nbsp;an&nbsp;already&nbsp;instantiated&nbsp;constitch.<a href="#Solver">Solver</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance.<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;solver&nbsp;instance,&nbsp;with&nbsp;an&nbsp;attribute&nbsp;positions&nbsp;containing&nbsp;a&nbsp;dict<br>
&nbsp;&nbsp;&nbsp;&nbsp;mapping&nbsp;image&nbsp;indices&nbsp;to&nbsp;their&nbsp;global&nbsp;positions</tt></dd></dl>

<dl><dt><a name="ConstraintSet-values"><strong>values</strong></a>(self)</dt></dl>

<hr>
Readonly properties defined here:<br>
<dl><dt><strong>composite</strong></dt>
<dd><tt>The&nbsp;composite&nbsp;that&nbsp;contains&nbsp;all&nbsp;the&nbsp;images&nbsp;of&nbsp;the&nbsp;constraints&nbsp;of&nbsp;this<br>
set.&nbsp;If&nbsp;constraints&nbsp;from&nbsp;a&nbsp;different&nbsp;constraint&nbsp;are&nbsp;added,&nbsp;an&nbsp;error&nbsp;will&nbsp;be<br>
raised.&nbsp;If&nbsp;this&nbsp;instance&nbsp;contains&nbsp;no&nbsp;constraints&nbsp;this&nbsp;will&nbsp;return&nbsp;None</tt></dd>
</dl>
<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes defined here:<br>
<dl><dt><strong>ATTRS</strong> = ['dx', 'dy', 'score', 'error', 'overlap', 'overlap_x', 'overlap_y', 'overlap_ratio', 'overlap_ratio_x', 'overlap_ratio_y', 'size', 'difference']</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="EfficientMeanMerger">class <strong>EfficientMeanMerger</strong></a>(<a href="constitch.merging.html#Merger">Merger</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>A&nbsp;version&nbsp;of&nbsp;<a href="#MeanMerger">MeanMerger</a>&nbsp;that&nbsp;does&nbsp;not&nbsp;require&nbsp;double&nbsp;the&nbsp;memory,&nbsp;however&nbsp;there&nbsp;is&nbsp;a&nbsp;small&nbsp;loss&nbsp;of&nbsp;<br>
precision&nbsp;as&nbsp;calculation&nbsp;errors&nbsp;can&nbsp;add&nbsp;up&nbsp;as&nbsp;images&nbsp;are&nbsp;merged.&nbsp;It&nbsp;is&nbsp;recommended&nbsp;to&nbsp;start&nbsp;with<br>
<a href="#MeanMerger">MeanMerger</a>&nbsp;and&nbsp;if&nbsp;memory&nbsp;becomes&nbsp;an&nbsp;issue&nbsp;switch&nbsp;to&nbsp;this&nbsp;one.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="constitch.merging.html#EfficientMeanMerger">EfficientMeanMerger</a></dd>
<dd><a href="constitch.merging.html#Merger">Merger</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="EfficientMeanMerger-add_image"><strong>add_image</strong></a>(self, image, location)</dt><dd><tt>Called&nbsp;to&nbsp;add&nbsp;an&nbsp;image.&nbsp;location&nbsp;is&nbsp;a&nbsp;tuple&nbsp;of&nbsp;slices&nbsp;used<br>
to&nbsp;select&nbsp;the&nbsp;area&nbsp;for&nbsp;the&nbsp;image,&nbsp;it&nbsp;is&nbsp;guaranteed&nbsp;to&nbsp;be&nbsp;the<br>
same&nbsp;size&nbsp;as&nbsp;image.</tt></dd></dl>

<dl><dt><a name="EfficientMeanMerger-create_image"><strong>create_image</strong></a>(self, image_shape, image_dtype)</dt><dd><tt>Init&nbsp;is&nbsp;called&nbsp;with&nbsp;the&nbsp;shape&nbsp;of&nbsp;the&nbsp;final&nbsp;image&nbsp;(may&nbsp;be<br>
more&nbsp;than&nbsp;2d)&nbsp;and&nbsp;the&nbsp;dtype.&nbsp;Normally&nbsp;a&nbsp;merger&nbsp;would&nbsp;create<br>
an&nbsp;image&nbsp;using&nbsp;this&nbsp;information.</tt></dd></dl>

<dl><dt><a name="EfficientMeanMerger-final_image"><strong>final_image</strong></a>(self)</dt><dd><tt>Called&nbsp;once&nbsp;to&nbsp;get&nbsp;the&nbsp;final&nbsp;image.&nbsp;It&nbsp;will&nbsp;only&nbsp;be&nbsp;called<br>
once&nbsp;when&nbsp;stitching,&nbsp;so&nbsp;final&nbsp;processing&nbsp;can&nbsp;take&nbsp;place&nbsp;and&nbsp;modify<br>
the&nbsp;stored&nbsp;image.&nbsp;Returns&nbsp;the&nbsp;final&nbsp;image&nbsp;and&nbsp;a&nbsp;mask&nbsp;for&nbsp;pixels&nbsp;that<br>
had&nbsp;no&nbsp;images.</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="constitch.merging.html#Merger">Merger</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="EfficientNearestMerger">class <strong>EfficientNearestMerger</strong></a>(<a href="constitch.merging.html#Merger">Merger</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>This&nbsp;merger&nbsp;does&nbsp;the&nbsp;same&nbsp;as&nbsp;the&nbsp;<a href="#NearestMerger">NearestMerger</a>&nbsp;but&nbsp;it&nbsp;does&nbsp;it&nbsp;with&nbsp;only&nbsp;an&nbsp;extra&nbsp;array&nbsp;of<br>
uint8,&nbsp;halfing&nbsp;the&nbsp;extra&nbsp;memory&nbsp;requirements.&nbsp;The&nbsp;downside&nbsp;is&nbsp;that&nbsp;it&nbsp;will&nbsp;only&nbsp;trim&nbsp;up&nbsp;to&nbsp;255<br>
pixels&nbsp;away&nbsp;from&nbsp;the&nbsp;edge&nbsp;of&nbsp;images,&nbsp;so&nbsp;if&nbsp;the&nbsp;overlap&nbsp;between&nbsp;your&nbsp;images&nbsp;is&nbsp;much&nbsp;larger&nbsp;than<br>
this,&nbsp;this&nbsp;merger&nbsp;will&nbsp;not&nbsp;give&nbsp;the&nbsp;same&nbsp;results.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="constitch.merging.html#EfficientNearestMerger">EfficientNearestMerger</a></dd>
<dd><a href="constitch.merging.html#Merger">Merger</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="EfficientNearestMerger-add_image"><strong>add_image</strong></a>(self, image, location)</dt><dd><tt>Called&nbsp;to&nbsp;add&nbsp;an&nbsp;image.&nbsp;location&nbsp;is&nbsp;a&nbsp;tuple&nbsp;of&nbsp;slices&nbsp;used<br>
to&nbsp;select&nbsp;the&nbsp;area&nbsp;for&nbsp;the&nbsp;image,&nbsp;it&nbsp;is&nbsp;guaranteed&nbsp;to&nbsp;be&nbsp;the<br>
same&nbsp;size&nbsp;as&nbsp;image.</tt></dd></dl>

<dl><dt><a name="EfficientNearestMerger-create_image"><strong>create_image</strong></a>(self, image_shape, image_dtype)</dt><dd><tt>Init&nbsp;is&nbsp;called&nbsp;with&nbsp;the&nbsp;shape&nbsp;of&nbsp;the&nbsp;final&nbsp;image&nbsp;(may&nbsp;be<br>
more&nbsp;than&nbsp;2d)&nbsp;and&nbsp;the&nbsp;dtype.&nbsp;Normally&nbsp;a&nbsp;merger&nbsp;would&nbsp;create<br>
an&nbsp;image&nbsp;using&nbsp;this&nbsp;information.</tt></dd></dl>

<dl><dt><a name="EfficientNearestMerger-final_image"><strong>final_image</strong></a>(self)</dt><dd><tt>Called&nbsp;once&nbsp;to&nbsp;get&nbsp;the&nbsp;final&nbsp;image.&nbsp;It&nbsp;will&nbsp;only&nbsp;be&nbsp;called<br>
once&nbsp;when&nbsp;stitching,&nbsp;so&nbsp;final&nbsp;processing&nbsp;can&nbsp;take&nbsp;place&nbsp;and&nbsp;modify<br>
the&nbsp;stored&nbsp;image.&nbsp;Returns&nbsp;the&nbsp;final&nbsp;image&nbsp;and&nbsp;a&nbsp;mask&nbsp;for&nbsp;pixels&nbsp;that<br>
had&nbsp;no&nbsp;images.</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="constitch.merging.html#Merger">Merger</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="FFTAligner">class <strong>FFTAligner</strong></a>(<a href="constitch.alignment.html#Aligner">Aligner</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#FFTAligner">FFTAligner</a>(num_peaks=2,&nbsp;precalculate_fft=True,&nbsp;downscale_factor=None,&nbsp;upscale_factor=1)<br>
&nbsp;<br>
An&nbsp;aligner&nbsp;that&nbsp;uses&nbsp;the&nbsp;phase&nbsp;cross&nbsp;correlation&nbsp;algorithm&nbsp;to&nbsp;estimate&nbsp;the&nbsp;proper&nbsp;alignment&nbsp;of&nbsp;two&nbsp;images.<br>
The&nbsp;algorithm&nbsp;is&nbsp;the&nbsp;same&nbsp;as&nbsp;described&nbsp;in&nbsp;Kuglin,&nbsp;Charles&nbsp;D.&nbsp;"The&nbsp;phase&nbsp;correlation&nbsp;image&nbsp;alignment&nbsp;method."<br>
<a href="http://boutigny.free.fr/Astronomie/AstroSources/Kuglin-Hines.pdf">http://boutigny.free.fr/Astronomie/AstroSources/Kuglin-Hines.pdf</a><br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="constitch.alignment.html#FFTAligner">FFTAligner</a></dd>
<dd><a href="constitch.alignment.html#Aligner">Aligner</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="FFTAligner-__init__"><strong>__init__</strong></a>(self, num_peaks=2, precalculate_fft=True, downscale_factor=None, upscale_factor=1)</dt><dd><tt>num_peaks:&nbsp;int&nbsp;default&nbsp;2<br>
&nbsp;&nbsp;&nbsp;&nbsp;Sets&nbsp;the&nbsp;number&nbsp;of&nbsp;peaks&nbsp;in&nbsp;the&nbsp;resulting&nbsp;phase&nbsp;cross&nbsp;correlation&nbsp;image&nbsp;to&nbsp;be&nbsp;checked.&nbsp;Sometimes&nbsp;the&nbsp;highest<br>
&nbsp;&nbsp;&nbsp;&nbsp;peak&nbsp;is&nbsp;not&nbsp;actually&nbsp;the&nbsp;best&nbsp;offset&nbsp;for&nbsp;alignment&nbsp;so&nbsp;checking&nbsp;multiple&nbsp;peaks&nbsp;can&nbsp;help&nbsp;find&nbsp;the&nbsp;one&nbsp;that<br>
&nbsp;&nbsp;&nbsp;&nbsp;has&nbsp;the&nbsp;highest&nbsp;ncc&nbsp;score.&nbsp;Increasing&nbsp;this&nbsp;will&nbsp;also&nbsp;increase&nbsp;processing&nbsp;time,&nbsp;possibly&nbsp;dramatically.<br>
precalculate_fft:&nbsp;bool&nbsp;default&nbsp;True<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;or&nbsp;not&nbsp;the&nbsp;FFT&nbsp;of&nbsp;the&nbsp;images&nbsp;should&nbsp;be&nbsp;precalculated&nbsp;and&nbsp;cached&nbsp;or&nbsp;be&nbsp;calculated&nbsp;every&nbsp;time.<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;FFT&nbsp;is&nbsp;able&nbsp;to&nbsp;be&nbsp;precalculated&nbsp;however&nbsp;it&nbsp;does&nbsp;take&nbsp;up&nbsp;a&nbsp;large&nbsp;amount&nbsp;of&nbsp;memory,&nbsp;so&nbsp;if&nbsp;memory<br>
&nbsp;&nbsp;&nbsp;&nbsp;is&nbsp;a&nbsp;limiting&nbsp;factor&nbsp;setting&nbsp;this&nbsp;to&nbsp;False&nbsp;can&nbsp;help<br>
downscale_factor:&nbsp;int,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;This&nbsp;algorithm&nbsp;is&nbsp;rather&nbsp;slow&nbsp;when&nbsp;calculating&nbsp;large&nbsp;numbers&nbsp;of&nbsp;constraints,&nbsp;and&nbsp;one&nbsp;way&nbsp;to&nbsp;improve<br>
&nbsp;&nbsp;&nbsp;&nbsp;speed&nbsp;is&nbsp;by&nbsp;downscaling&nbsp;the&nbsp;images&nbsp;before&nbsp;running&nbsp;the&nbsp;algorithm.&nbsp;This&nbsp;will&nbsp;improve&nbsp;runtime&nbsp;at&nbsp;the&nbsp;expense<br>
&nbsp;&nbsp;&nbsp;&nbsp;of&nbsp;precision,&nbsp;the&nbsp;constraints&nbsp;calculated&nbsp;will&nbsp;have&nbsp;a&nbsp;nonzero&nbsp;error&nbsp;value.&nbsp;Also,&nbsp;if&nbsp;the&nbsp;downscale&nbsp;factor<br>
&nbsp;&nbsp;&nbsp;&nbsp;is&nbsp;large&nbsp;enough&nbsp;the&nbsp;algorithm&nbsp;can&nbsp;begin&nbsp;to&nbsp;fail&nbsp;and&nbsp;not&nbsp;find&nbsp;any&nbsp;overlap,&nbsp;in&nbsp;general&nbsp;the&nbsp;largest&nbsp;recommended<br>
&nbsp;&nbsp;&nbsp;&nbsp;value&nbsp;is&nbsp;around&nbsp;32,&nbsp;but&nbsp;it&nbsp;depends&nbsp;on&nbsp;how&nbsp;large&nbsp;the&nbsp;features&nbsp;in&nbsp;your&nbsp;images&nbsp;are.</tt></dd></dl>

<dl><dt><a name="FFTAligner-align"><strong>align</strong></a>(self, constraint, precalc1=None, precalc2=None)</dt><dd><tt>Performs&nbsp;the&nbsp;alignment&nbsp;of&nbsp;two&nbsp;images,&nbsp;finding&nbsp;the&nbsp;pixel&nbsp;offset&nbsp;that&nbsp;best&nbsp;aligns&nbsp;the<br>
two&nbsp;images.&nbsp;The&nbsp;offset&nbsp;should&nbsp;be&nbsp;from&nbsp;image1&nbsp;to&nbsp;image2.&nbsp;The&nbsp;return&nbsp;value&nbsp;should&nbsp;be&nbsp;a&nbsp;<a href="#Constraint">Constraint</a><br>
<a href="builtins.html#object">object</a>,&nbsp;with&nbsp;at&nbsp;least&nbsp;the&nbsp;dx,&nbsp;dy&nbsp;fields&nbsp;filled&nbsp;in&nbsp;to&nbsp;represent&nbsp;the&nbsp;offset&nbsp;of&nbsp;image2&nbsp;needed<br>
to&nbsp;align&nbsp;the&nbsp;two&nbsp;images.&nbsp;If&nbsp;the&nbsp;function&nbsp;finds&nbsp;the&nbsp;images&nbsp;don't&nbsp;overlap,&nbsp;None&nbsp;should&nbsp;be&nbsp;returned.<br>
If&nbsp;a&nbsp;constraint&nbsp;is&nbsp;specified,&nbsp;this&nbsp;method&nbsp;should&nbsp;only&nbsp;return&nbsp;a&nbsp;constraint&nbsp;that&nbsp;fits&nbsp;within&nbsp;the&nbsp;error<br>
of&nbsp;given&nbsp;constraint,&nbsp;meaning&nbsp;within&nbsp;constraint.error&nbsp;pixels&nbsp;from&nbsp;the&nbsp;(constraint.dx,&nbsp;constraint.dy)<br>
offset.</tt></dd></dl>

<dl><dt><a name="FFTAligner-align_full"><strong>align_full</strong></a>(self, constraint, precalc1=None, precalc2=None)</dt></dl>

<dl><dt><a name="FFTAligner-precalculate"><strong>precalculate</strong></a>(self, image, box=None)</dt><dd><tt>Performs&nbsp;an&nbsp;arbitrary&nbsp;precalculation&nbsp;step&nbsp;specific&nbsp;to&nbsp;the&nbsp;alignment&nbsp;algorithm.<br>
This&nbsp;would&nbsp;be&nbsp;a&nbsp;step&nbsp;in&nbsp;the&nbsp;algorithm&nbsp;that&nbsp;only&nbsp;has&nbsp;to&nbsp;be&nbsp;run&nbsp;once&nbsp;per&nbsp;image,<br>
and&nbsp;can&nbsp;be&nbsp;cached&nbsp;for&nbsp;each&nbsp;calculation&nbsp;done&nbsp;with&nbsp;the&nbsp;same&nbsp;image.&nbsp;The&nbsp;result&nbsp;of<br>
this&nbsp;function&nbsp;will&nbsp;be&nbsp;passed&nbsp;to&nbsp;the&nbsp;align&nbsp;function&nbsp;as&nbsp;the&nbsp;precalc1&nbsp;or&nbsp;precalc2&nbsp;argument</tt></dd></dl>

<hr>
Methods inherited from <a href="constitch.alignment.html#Aligner">Aligner</a>:<br>
<dl><dt><a name="FFTAligner-precalculate_if_needed"><strong>precalculate_if_needed</strong></a>(self, constraint, precalc1, precalc2)</dt></dl>

<dl><dt><a name="FFTAligner-resize_if_needed"><strong>resize_if_needed</strong></a>(self, image, box=None, downscale_factor=None, padding=None)</dt><dd><tt>#&nbsp;Helper&nbsp;functions&nbsp;for&nbsp;subclasses:</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="constitch.alignment.html#Aligner">Aligner</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="FeatureAligner">class <strong>FeatureAligner</strong></a>(<a href="constitch.alignment.html#Aligner">Aligner</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#FeatureAligner">FeatureAligner</a>(num_features=2000)<br>
&nbsp;<br>
<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="constitch.alignment.html#FeatureAligner">FeatureAligner</a></dd>
<dd><a href="constitch.alignment.html#Aligner">Aligner</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="FeatureAligner-__init__"><strong>__init__</strong></a>(self, num_features=2000)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="FeatureAligner-align"><strong>align</strong></a>(self, constraint, precalc1=None, precalc2=None)</dt><dd><tt>Performs&nbsp;the&nbsp;alignment&nbsp;of&nbsp;two&nbsp;images,&nbsp;finding&nbsp;the&nbsp;pixel&nbsp;offset&nbsp;that&nbsp;best&nbsp;aligns&nbsp;the<br>
two&nbsp;images.&nbsp;The&nbsp;offset&nbsp;should&nbsp;be&nbsp;from&nbsp;image1&nbsp;to&nbsp;image2.&nbsp;The&nbsp;return&nbsp;value&nbsp;should&nbsp;be&nbsp;a&nbsp;<a href="#Constraint">Constraint</a><br>
<a href="builtins.html#object">object</a>,&nbsp;with&nbsp;at&nbsp;least&nbsp;the&nbsp;dx,&nbsp;dy&nbsp;fields&nbsp;filled&nbsp;in&nbsp;to&nbsp;represent&nbsp;the&nbsp;offset&nbsp;of&nbsp;image2&nbsp;needed<br>
to&nbsp;align&nbsp;the&nbsp;two&nbsp;images.&nbsp;If&nbsp;the&nbsp;function&nbsp;finds&nbsp;the&nbsp;images&nbsp;don't&nbsp;overlap,&nbsp;None&nbsp;should&nbsp;be&nbsp;returned.<br>
If&nbsp;a&nbsp;constraint&nbsp;is&nbsp;specified,&nbsp;this&nbsp;method&nbsp;should&nbsp;only&nbsp;return&nbsp;a&nbsp;constraint&nbsp;that&nbsp;fits&nbsp;within&nbsp;the&nbsp;error<br>
of&nbsp;given&nbsp;constraint,&nbsp;meaning&nbsp;within&nbsp;constraint.error&nbsp;pixels&nbsp;from&nbsp;the&nbsp;(constraint.dx,&nbsp;constraint.dy)<br>
offset.</tt></dd></dl>

<dl><dt><a name="FeatureAligner-precalculate"><strong>precalculate</strong></a>(self, image, box=None)</dt><dd><tt>Performs&nbsp;an&nbsp;arbitrary&nbsp;precalculation&nbsp;step&nbsp;specific&nbsp;to&nbsp;the&nbsp;alignment&nbsp;algorithm.<br>
This&nbsp;would&nbsp;be&nbsp;a&nbsp;step&nbsp;in&nbsp;the&nbsp;algorithm&nbsp;that&nbsp;only&nbsp;has&nbsp;to&nbsp;be&nbsp;run&nbsp;once&nbsp;per&nbsp;image,<br>
and&nbsp;can&nbsp;be&nbsp;cached&nbsp;for&nbsp;each&nbsp;calculation&nbsp;done&nbsp;with&nbsp;the&nbsp;same&nbsp;image.&nbsp;The&nbsp;result&nbsp;of<br>
this&nbsp;function&nbsp;will&nbsp;be&nbsp;passed&nbsp;to&nbsp;the&nbsp;align&nbsp;function&nbsp;as&nbsp;the&nbsp;precalc1&nbsp;or&nbsp;precalc2&nbsp;argument</tt></dd></dl>

<hr>
Methods inherited from <a href="constitch.alignment.html#Aligner">Aligner</a>:<br>
<dl><dt><a name="FeatureAligner-precalculate_if_needed"><strong>precalculate_if_needed</strong></a>(self, constraint, precalc1, precalc2)</dt></dl>

<dl><dt><a name="FeatureAligner-resize_if_needed"><strong>resize_if_needed</strong></a>(self, image, box=None, downscale_factor=None, padding=None)</dt><dd><tt>#&nbsp;Helper&nbsp;functions&nbsp;for&nbsp;subclasses:</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="constitch.alignment.html#Aligner">Aligner</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="GlobalStageModel">class <strong>GlobalStageModel</strong></a>(<a href="constitch.stage_model.html#ConversionStageModel">ConversionStageModel</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#GlobalStageModel">GlobalStageModel</a>(model=None)<br>
&nbsp;<br>
Stage&nbsp;model&nbsp;that&nbsp;takes&nbsp;into&nbsp;account&nbsp;the&nbsp;global&nbsp;positions&nbsp;of&nbsp;the<br>
two&nbsp;images,&nbsp;by&nbsp;passing&nbsp;both&nbsp;image&nbsp;positions&nbsp;to&nbsp;the&nbsp;model&nbsp;unchanged.<br>
&nbsp;<br>
This&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;just&nbsp;using&nbsp;the&nbsp;internal&nbsp;model&nbsp;directly,&nbsp;this&nbsp;is<br>
just&nbsp;a&nbsp;separate&nbsp;class&nbsp;for&nbsp;documentation&nbsp;and&nbsp;consistency.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="constitch.stage_model.html#GlobalStageModel">GlobalStageModel</a></dd>
<dd><a href="constitch.stage_model.html#ConversionStageModel">ConversionStageModel</a></dd>
<dd><a href="sklearn.base.html#BaseEstimator">sklearn.base.BaseEstimator</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="GlobalStageModel-__init__"><strong>__init__</strong></a>(self, model=None)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="GlobalStageModel-conversion_func"><strong>conversion_func</strong></a>(self, poses1, poses2)</dt></dl>

<hr>
Methods inherited from <a href="constitch.stage_model.html#ConversionStageModel">ConversionStageModel</a>:<br>
<dl><dt><a name="GlobalStageModel-__repr__"><strong>__repr__</strong></a>(self)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="GlobalStageModel-__str__"><strong>__str__</strong></a>(self)</dt><dd><tt>Return&nbsp;str(self).</tt></dd></dl>

<dl><dt><a name="GlobalStageModel-fit"><strong>fit</strong></a>(self, X, y)</dt></dl>

<dl><dt><a name="GlobalStageModel-fit_predict"><strong>fit_predict</strong></a>(self, X, y)</dt></dl>

<dl><dt><a name="GlobalStageModel-predict"><strong>predict</strong></a>(self, X)</dt></dl>

<dl><dt><a name="GlobalStageModel-score"><strong>score</strong></a>(self, X, y)</dt></dl>

<dl><dt><a name="GlobalStageModel-split_X"><strong>split_X</strong></a>(self, X)</dt></dl>

<hr>
Methods inherited from <a href="sklearn.base.html#BaseEstimator">sklearn.base.BaseEstimator</a>:<br>
<dl><dt><a name="GlobalStageModel-__getstate__"><strong>__getstate__</strong></a>(self)</dt></dl>

<dl><dt><a name="GlobalStageModel-__setstate__"><strong>__setstate__</strong></a>(self, state)</dt></dl>

<dl><dt><a name="GlobalStageModel-get_params"><strong>get_params</strong></a>(self, deep=True)</dt><dd><tt>Get&nbsp;parameters&nbsp;for&nbsp;this&nbsp;estimator.<br>
&nbsp;<br>
Parameters<br>
----------<br>
deep&nbsp;:&nbsp;bool,&nbsp;default=True<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True,&nbsp;will&nbsp;return&nbsp;the&nbsp;parameters&nbsp;for&nbsp;this&nbsp;estimator&nbsp;and<br>
&nbsp;&nbsp;&nbsp;&nbsp;contained&nbsp;subobjects&nbsp;that&nbsp;are&nbsp;estimators.<br>
&nbsp;<br>
Returns<br>
-------<br>
params&nbsp;:&nbsp;dict<br>
&nbsp;&nbsp;&nbsp;&nbsp;Parameter&nbsp;names&nbsp;mapped&nbsp;to&nbsp;their&nbsp;values.</tt></dd></dl>

<dl><dt><a name="GlobalStageModel-set_params"><strong>set_params</strong></a>(self, **params)</dt><dd><tt>Set&nbsp;the&nbsp;parameters&nbsp;of&nbsp;this&nbsp;estimator.<br>
&nbsp;<br>
The&nbsp;method&nbsp;works&nbsp;on&nbsp;simple&nbsp;estimators&nbsp;as&nbsp;well&nbsp;as&nbsp;on&nbsp;nested&nbsp;objects<br>
(such&nbsp;as&nbsp;:class:`~sklearn.pipeline.Pipeline`).&nbsp;The&nbsp;latter&nbsp;have<br>
parameters&nbsp;of&nbsp;the&nbsp;form&nbsp;``&lt;component&gt;__&lt;parameter&gt;``&nbsp;so&nbsp;that&nbsp;it's<br>
possible&nbsp;to&nbsp;update&nbsp;each&nbsp;component&nbsp;of&nbsp;a&nbsp;nested&nbsp;<a href="builtins.html#object">object</a>.<br>
&nbsp;<br>
Parameters<br>
----------<br>
**params&nbsp;:&nbsp;dict<br>
&nbsp;&nbsp;&nbsp;&nbsp;Estimator&nbsp;parameters.<br>
&nbsp;<br>
Returns<br>
-------<br>
self&nbsp;:&nbsp;estimator&nbsp;instance<br>
&nbsp;&nbsp;&nbsp;&nbsp;Estimator&nbsp;instance.</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="sklearn.base.html#BaseEstimator">sklearn.base.BaseEstimator</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="LPSolver">class <strong>LPSolver</strong></a>(<a href="constitch.solving.html#LinearSolver">LinearSolver</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#LPSolver">LPSolver</a>(integral=True)<br>
&nbsp;<br>
<a href="#Solver">Solver</a>&nbsp;that&nbsp;uses&nbsp;(integer)&nbsp;linear&nbsp;programming&nbsp;to&nbsp;find&nbsp;a&nbsp;solution&nbsp;minimizing&nbsp;the&nbsp;mean<br>
absolute&nbsp;error&nbsp;of&nbsp;the&nbsp;system&nbsp;of&nbsp;equations&nbsp;specified&nbsp;by&nbsp;the&nbsp;constraints.&nbsp;This<br>
differs&nbsp;from&nbsp;<a href="#MAESolver">MAESolver</a>&nbsp;as&nbsp;by&nbsp;using&nbsp;integer&nbsp;linear&nbsp;programming&nbsp;we&nbsp;can&nbsp;constrain<br>
the&nbsp;resulting&nbsp;values&nbsp;to&nbsp;be&nbsp;integers,&nbsp;which&nbsp;removes&nbsp;any&nbsp;errors&nbsp;that&nbsp;might&nbsp;come&nbsp;from<br>
rounding&nbsp;the&nbsp;solution&nbsp;values.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="constitch.solving.html#LPSolver">LPSolver</a></dd>
<dd><a href="constitch.solving.html#LinearSolver">LinearSolver</a></dd>
<dd><a href="constitch.solving.html#Solver">Solver</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="LPSolver-__init__"><strong>__init__</strong></a>(self, integral=True)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="LPSolver-solve_matrix"><strong>solve_matrix</strong></a>(self, solution_mat, solution_vals, initial_values)</dt></dl>

<hr>
Methods inherited from <a href="constitch.solving.html#LinearSolver">LinearSolver</a>:<br>
<dl><dt><a name="LPSolver-make_constraint_matrix"><strong>make_constraint_matrix</strong></a>(self, constraints, initial_poses)</dt></dl>

<dl><dt><a name="LPSolver-make_positions"><strong>make_positions</strong></a>(self, initial_poses, poses)</dt></dl>

<dl><dt><a name="LPSolver-score_func"><strong>score_func</strong></a>(self, constraint)</dt></dl>

<dl><dt><a name="LPSolver-solve"><strong>solve</strong></a>(self, constraints, initial_poses)</dt><dd><tt>Solve&nbsp;the&nbsp;global&nbsp;positions&nbsp;for&nbsp;images&nbsp;given&nbsp;the&nbsp;constraints&nbsp;and&nbsp;estimated&nbsp;positions.<br>
returns&nbsp;the&nbsp;xy&nbsp;position&nbsp;for&nbsp;each&nbsp;image,&nbsp;mapping&nbsp;the&nbsp;image&nbsp;index&nbsp;to&nbsp;the&nbsp;position<br>
with&nbsp;a&nbsp;dictionary.<br>
Additionally&nbsp;the&nbsp;constraints&nbsp;dictionary&nbsp;can&nbsp;be&nbsp;returned&nbsp;as&nbsp;the&nbsp;second&nbsp;return&nbsp;value,&nbsp;which<br>
will&nbsp;replace&nbsp;the&nbsp;constraints&nbsp;in&nbsp;the&nbsp;composite&nbsp;with&nbsp;the&nbsp;ones&nbsp;returned,&nbsp;filtering&nbsp;outliers.</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="constitch.solving.html#Solver">Solver</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="LastMerger">class <strong>LastMerger</strong></a>(<a href="constitch.merging.html#Merger">Merger</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>This&nbsp;is&nbsp;the&nbsp;simplest&nbsp;merger,&nbsp;overlap&nbsp;is&nbsp;decided&nbsp;just&nbsp;by&nbsp;which&nbsp;image&nbsp;was&nbsp;added&nbsp;last.<br>
This&nbsp;also&nbsp;means&nbsp;it&nbsp;has&nbsp;no&nbsp;extra&nbsp;memory&nbsp;requirements,&nbsp;if&nbsp;your&nbsp;images&nbsp;have&nbsp;no&nbsp;overlap&nbsp;or<br>
you&nbsp;don't&nbsp;need&nbsp;any&nbsp;merging&nbsp;this&nbsp;is&nbsp;the&nbsp;best&nbsp;choice.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="constitch.merging.html#LastMerger">LastMerger</a></dd>
<dd><a href="constitch.merging.html#Merger">Merger</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="LastMerger-add_image"><strong>add_image</strong></a>(self, image, location)</dt><dd><tt>Called&nbsp;to&nbsp;add&nbsp;an&nbsp;image.&nbsp;location&nbsp;is&nbsp;a&nbsp;tuple&nbsp;of&nbsp;slices&nbsp;used<br>
to&nbsp;select&nbsp;the&nbsp;area&nbsp;for&nbsp;the&nbsp;image,&nbsp;it&nbsp;is&nbsp;guaranteed&nbsp;to&nbsp;be&nbsp;the<br>
same&nbsp;size&nbsp;as&nbsp;image.</tt></dd></dl>

<dl><dt><a name="LastMerger-create_image"><strong>create_image</strong></a>(self, image_shape, image_dtype)</dt><dd><tt>Init&nbsp;is&nbsp;called&nbsp;with&nbsp;the&nbsp;shape&nbsp;of&nbsp;the&nbsp;final&nbsp;image&nbsp;(may&nbsp;be<br>
more&nbsp;than&nbsp;2d)&nbsp;and&nbsp;the&nbsp;dtype.&nbsp;Normally&nbsp;a&nbsp;merger&nbsp;would&nbsp;create<br>
an&nbsp;image&nbsp;using&nbsp;this&nbsp;information.</tt></dd></dl>

<dl><dt><a name="LastMerger-final_image"><strong>final_image</strong></a>(self)</dt><dd><tt>Called&nbsp;once&nbsp;to&nbsp;get&nbsp;the&nbsp;final&nbsp;image.&nbsp;It&nbsp;will&nbsp;only&nbsp;be&nbsp;called<br>
once&nbsp;when&nbsp;stitching,&nbsp;so&nbsp;final&nbsp;processing&nbsp;can&nbsp;take&nbsp;place&nbsp;and&nbsp;modify<br>
the&nbsp;stored&nbsp;image.&nbsp;Returns&nbsp;the&nbsp;final&nbsp;image&nbsp;and&nbsp;a&nbsp;mask&nbsp;for&nbsp;pixels&nbsp;that<br>
had&nbsp;no&nbsp;images.</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="constitch.merging.html#Merger">Merger</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="LinearSolver">class <strong>LinearSolver</strong></a>(<a href="constitch.solving.html#Solver">Solver</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#LinearSolver">LinearSolver</a>(model=None)<br>
&nbsp;<br>
<a href="#Solver">Solver</a>&nbsp;that&nbsp;represents&nbsp;the&nbsp;constraints&nbsp;as&nbsp;an&nbsp;overconstrained&nbsp;system&nbsp;of&nbsp;equations,&nbsp;and<br>
solves&nbsp;it&nbsp;using&nbsp;least&nbsp;squares.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="constitch.solving.html#LinearSolver">LinearSolver</a></dd>
<dd><a href="constitch.solving.html#Solver">Solver</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="LinearSolver-__init__"><strong>__init__</strong></a>(self, model=None)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="LinearSolver-make_constraint_matrix"><strong>make_constraint_matrix</strong></a>(self, constraints, initial_poses)</dt></dl>

<dl><dt><a name="LinearSolver-make_positions"><strong>make_positions</strong></a>(self, initial_poses, poses)</dt></dl>

<dl><dt><a name="LinearSolver-score_func"><strong>score_func</strong></a>(self, constraint)</dt></dl>

<dl><dt><a name="LinearSolver-solve"><strong>solve</strong></a>(self, constraints, initial_poses)</dt><dd><tt>Solve&nbsp;the&nbsp;global&nbsp;positions&nbsp;for&nbsp;images&nbsp;given&nbsp;the&nbsp;constraints&nbsp;and&nbsp;estimated&nbsp;positions.<br>
returns&nbsp;the&nbsp;xy&nbsp;position&nbsp;for&nbsp;each&nbsp;image,&nbsp;mapping&nbsp;the&nbsp;image&nbsp;index&nbsp;to&nbsp;the&nbsp;position<br>
with&nbsp;a&nbsp;dictionary.<br>
Additionally&nbsp;the&nbsp;constraints&nbsp;dictionary&nbsp;can&nbsp;be&nbsp;returned&nbsp;as&nbsp;the&nbsp;second&nbsp;return&nbsp;value,&nbsp;which<br>
will&nbsp;replace&nbsp;the&nbsp;constraints&nbsp;in&nbsp;the&nbsp;composite&nbsp;with&nbsp;the&nbsp;ones&nbsp;returned,&nbsp;filtering&nbsp;outliers.</tt></dd></dl>

<dl><dt><a name="LinearSolver-solve_matrix"><strong>solve_matrix</strong></a>(self, solution_mat, solution_vals, initial_values)</dt></dl>

<hr>
Data descriptors inherited from <a href="constitch.solving.html#Solver">Solver</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="MAESolver">class <strong>MAESolver</strong></a>(<a href="constitch.solving.html#LinearSolver">LinearSolver</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#MAESolver">MAESolver</a>(**kwargs)<br>
&nbsp;<br>
<a href="#Solver">Solver</a>&nbsp;that&nbsp;performs&nbsp;quantile&nbsp;regression&nbsp;instead&nbsp;of&nbsp;ordinary&nbsp;least&nbsp;squares<br>
to&nbsp;solve&nbsp;the&nbsp;system&nbsp;of&nbsp;equations&nbsp;described&nbsp;by&nbsp;constraints.&nbsp;Equivalent&nbsp;to&nbsp;minimizing<br>
the&nbsp;mean&nbsp;absolute&nbsp;error,&nbsp;this&nbsp;is&nbsp;much&nbsp;more&nbsp;outlier&nbsp;resistant&nbsp;that&nbsp;minimizing&nbsp;MSE<br>
and&nbsp;should&nbsp;provide&nbsp;better&nbsp;results&nbsp;when&nbsp;there&nbsp;are&nbsp;erroneous&nbsp;constraints&nbsp;present.<br>
This&nbsp;is&nbsp;identical&nbsp;to&nbsp;<a href="#LinearSolver">LinearSolver</a>&nbsp;except&nbsp;that&nbsp;the&nbsp;linear&nbsp;model&nbsp;used&nbsp;is&nbsp;QuantileRegressor.<br>
Any&nbsp;parameters&nbsp;passed&nbsp;to&nbsp;the&nbsp;constructor&nbsp;are&nbsp;forwared&nbsp;to&nbsp;the&nbsp;constructor&nbsp;of<br>
sklearn.linear_model.QuantileRegressor.&nbsp;By&nbsp;default&nbsp;the&nbsp;L1&nbsp;regularization&nbsp;constant<br>
alpha=0&nbsp;and&nbsp;fit_intercept=False,&nbsp;unless&nbsp;specified&nbsp;in&nbsp;the&nbsp;constructor.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="constitch.solving.html#MAESolver">MAESolver</a></dd>
<dd><a href="constitch.solving.html#LinearSolver">LinearSolver</a></dd>
<dd><a href="constitch.solving.html#Solver">Solver</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="MAESolver-__init__"><strong>__init__</strong></a>(self, **kwargs)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="MAESolver-score_func"><strong>score_func</strong></a>(self, constraint)</dt></dl>

<hr>
Methods inherited from <a href="constitch.solving.html#LinearSolver">LinearSolver</a>:<br>
<dl><dt><a name="MAESolver-make_constraint_matrix"><strong>make_constraint_matrix</strong></a>(self, constraints, initial_poses)</dt></dl>

<dl><dt><a name="MAESolver-make_positions"><strong>make_positions</strong></a>(self, initial_poses, poses)</dt></dl>

<dl><dt><a name="MAESolver-solve"><strong>solve</strong></a>(self, constraints, initial_poses)</dt><dd><tt>Solve&nbsp;the&nbsp;global&nbsp;positions&nbsp;for&nbsp;images&nbsp;given&nbsp;the&nbsp;constraints&nbsp;and&nbsp;estimated&nbsp;positions.<br>
returns&nbsp;the&nbsp;xy&nbsp;position&nbsp;for&nbsp;each&nbsp;image,&nbsp;mapping&nbsp;the&nbsp;image&nbsp;index&nbsp;to&nbsp;the&nbsp;position<br>
with&nbsp;a&nbsp;dictionary.<br>
Additionally&nbsp;the&nbsp;constraints&nbsp;dictionary&nbsp;can&nbsp;be&nbsp;returned&nbsp;as&nbsp;the&nbsp;second&nbsp;return&nbsp;value,&nbsp;which<br>
will&nbsp;replace&nbsp;the&nbsp;constraints&nbsp;in&nbsp;the&nbsp;composite&nbsp;with&nbsp;the&nbsp;ones&nbsp;returned,&nbsp;filtering&nbsp;outliers.</tt></dd></dl>

<dl><dt><a name="MAESolver-solve_matrix"><strong>solve_matrix</strong></a>(self, solution_mat, solution_vals, initial_values)</dt></dl>

<hr>
Data descriptors inherited from <a href="constitch.solving.html#Solver">Solver</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="MaskMerger">class <strong>MaskMerger</strong></a>(<a href="constitch.merging.html#NearestMerger">NearestMerger</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#MaskMerger">MaskMerger</a>(overlap_threshold=0.75)<br>
&nbsp;<br>
This&nbsp;merger&nbsp;is&nbsp;specifically&nbsp;for&nbsp;merging&nbsp;an&nbsp;image&nbsp;mask,&nbsp;where&nbsp;each&nbsp;integer&nbsp;represents<br>
an&nbsp;independent&nbsp;class,&nbsp;for&nbsp;example&nbsp;cell&nbsp;segmentation&nbsp;masks.&nbsp;Other&nbsp;merging&nbsp;techniques&nbsp;won't<br>
work&nbsp;on&nbsp;these&nbsp;image&nbsp;masks.&nbsp;This&nbsp;merger&nbsp;first&nbsp;makes&nbsp;sure&nbsp;that&nbsp;every&nbsp;mask&nbsp;in&nbsp;each&nbsp;image<br>
has&nbsp;a&nbsp;unique&nbsp;integer&nbsp;value,&nbsp;then&nbsp;merges&nbsp;overlapping&nbsp;sections&nbsp;by&nbsp;going&nbsp;through&nbsp;the<br>
masks&nbsp;and&nbsp;combining&nbsp;masks&nbsp;that&nbsp;are&nbsp;mostly&nbsp;overlapping&nbsp;in&nbsp;both&nbsp;images.&nbsp;The&nbsp;amount<br>
of&nbsp;overlap&nbsp;needed&nbsp;to&nbsp;combine&nbsp;masks&nbsp;is&nbsp;the&nbsp;overlap_threshold.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="constitch.merging.html#MaskMerger">MaskMerger</a></dd>
<dd><a href="constitch.merging.html#NearestMerger">NearestMerger</a></dd>
<dd><a href="constitch.merging.html#Merger">Merger</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="MaskMerger-__init__"><strong>__init__</strong></a>(self, overlap_threshold=0.75)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="MaskMerger-add_image"><strong>add_image</strong></a>(self, image, location)</dt><dd><tt>Called&nbsp;to&nbsp;add&nbsp;an&nbsp;image.&nbsp;location&nbsp;is&nbsp;a&nbsp;tuple&nbsp;of&nbsp;slices&nbsp;used<br>
to&nbsp;select&nbsp;the&nbsp;area&nbsp;for&nbsp;the&nbsp;image,&nbsp;it&nbsp;is&nbsp;guaranteed&nbsp;to&nbsp;be&nbsp;the<br>
same&nbsp;size&nbsp;as&nbsp;image.</tt></dd></dl>

<dl><dt><a name="MaskMerger-create_image"><strong>create_image</strong></a>(self, image_shape, image_dtype)</dt><dd><tt>Init&nbsp;is&nbsp;called&nbsp;with&nbsp;the&nbsp;shape&nbsp;of&nbsp;the&nbsp;final&nbsp;image&nbsp;(may&nbsp;be<br>
more&nbsp;than&nbsp;2d)&nbsp;and&nbsp;the&nbsp;dtype.&nbsp;Normally&nbsp;a&nbsp;merger&nbsp;would&nbsp;create<br>
an&nbsp;image&nbsp;using&nbsp;this&nbsp;information.</tt></dd></dl>

<hr>
Methods inherited from <a href="constitch.merging.html#NearestMerger">NearestMerger</a>:<br>
<dl><dt><a name="MaskMerger-final_image"><strong>final_image</strong></a>(self)</dt><dd><tt>Called&nbsp;once&nbsp;to&nbsp;get&nbsp;the&nbsp;final&nbsp;image.&nbsp;It&nbsp;will&nbsp;only&nbsp;be&nbsp;called<br>
once&nbsp;when&nbsp;stitching,&nbsp;so&nbsp;final&nbsp;processing&nbsp;can&nbsp;take&nbsp;place&nbsp;and&nbsp;modify<br>
the&nbsp;stored&nbsp;image.&nbsp;Returns&nbsp;the&nbsp;final&nbsp;image&nbsp;and&nbsp;a&nbsp;mask&nbsp;for&nbsp;pixels&nbsp;that<br>
had&nbsp;no&nbsp;images.</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="constitch.merging.html#Merger">Merger</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="MeanMerger">class <strong>MeanMerger</strong></a>(<a href="constitch.merging.html#Merger">Merger</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>A&nbsp;merger&nbsp;that&nbsp;calculates&nbsp;the&nbsp;mean&nbsp;of&nbsp;any&nbsp;overlapping&nbsp;areas.&nbsp;This&nbsp;requires<br>
storing&nbsp;the&nbsp;whole&nbsp;image&nbsp;using&nbsp;a&nbsp;larger&nbsp;dtype,&nbsp;eg&nbsp;when&nbsp;merging&nbsp;uint16&nbsp;images<br>
the&nbsp;whole&nbsp;image&nbsp;will&nbsp;be&nbsp;stored&nbsp;as&nbsp;a&nbsp;uint32&nbsp;image&nbsp;to&nbsp;account&nbsp;for&nbsp;possible&nbsp;overflow.<br>
This&nbsp;will&nbsp;double&nbsp;the&nbsp;memory&nbsp;requirements&nbsp;compared&nbsp;to&nbsp;other&nbsp;mergers&nbsp;such&nbsp;as&nbsp;<a href="#LastMerger">LastMerger</a><br>
or&nbsp;<a href="#EfficientMeanMerger">EfficientMeanMerger</a>.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="constitch.merging.html#MeanMerger">MeanMerger</a></dd>
<dd><a href="constitch.merging.html#Merger">Merger</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="MeanMerger-add_image"><strong>add_image</strong></a>(self, image, location)</dt><dd><tt>Called&nbsp;to&nbsp;add&nbsp;an&nbsp;image.&nbsp;location&nbsp;is&nbsp;a&nbsp;tuple&nbsp;of&nbsp;slices&nbsp;used<br>
to&nbsp;select&nbsp;the&nbsp;area&nbsp;for&nbsp;the&nbsp;image,&nbsp;it&nbsp;is&nbsp;guaranteed&nbsp;to&nbsp;be&nbsp;the<br>
same&nbsp;size&nbsp;as&nbsp;image.</tt></dd></dl>

<dl><dt><a name="MeanMerger-create_image"><strong>create_image</strong></a>(self, image_shape, image_dtype)</dt><dd><tt>Init&nbsp;is&nbsp;called&nbsp;with&nbsp;the&nbsp;shape&nbsp;of&nbsp;the&nbsp;final&nbsp;image&nbsp;(may&nbsp;be<br>
more&nbsp;than&nbsp;2d)&nbsp;and&nbsp;the&nbsp;dtype.&nbsp;Normally&nbsp;a&nbsp;merger&nbsp;would&nbsp;create<br>
an&nbsp;image&nbsp;using&nbsp;this&nbsp;information.</tt></dd></dl>

<dl><dt><a name="MeanMerger-final_image"><strong>final_image</strong></a>(self)</dt><dd><tt>Called&nbsp;once&nbsp;to&nbsp;get&nbsp;the&nbsp;final&nbsp;image.&nbsp;It&nbsp;will&nbsp;only&nbsp;be&nbsp;called<br>
once&nbsp;when&nbsp;stitching,&nbsp;so&nbsp;final&nbsp;processing&nbsp;can&nbsp;take&nbsp;place&nbsp;and&nbsp;modify<br>
the&nbsp;stored&nbsp;image.&nbsp;Returns&nbsp;the&nbsp;final&nbsp;image&nbsp;and&nbsp;a&nbsp;mask&nbsp;for&nbsp;pixels&nbsp;that<br>
had&nbsp;no&nbsp;images.</tt></dd></dl>

<dl><dt><a name="MeanMerger-promote_dtype"><strong>promote_dtype</strong></a>(self, dtype)</dt></dl>

<hr>
Data descriptors inherited from <a href="constitch.merging.html#Merger">Merger</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Merger">class <strong>Merger</strong></a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Abstract&nbsp;class&nbsp;that&nbsp;specifies&nbsp;the&nbsp;methods&nbsp;required&nbsp;for&nbsp;an&nbsp;image&nbsp;merger.<br>
At&nbsp;its&nbsp;heart&nbsp;an&nbsp;image&nbsp;merger&nbsp;is&nbsp;a&nbsp;method&nbsp;for&nbsp;handling&nbsp;multiple&nbsp;values&nbsp;at&nbsp;one<br>
pixel&nbsp;location,&nbsp;either&nbsp;taking&nbsp;one,&nbsp;combining&nbsp;them&nbsp;all,&nbsp;or&nbsp;some&nbsp;other&nbsp;method.<br>
Using&nbsp;this&nbsp;the&nbsp;merger&nbsp;is&nbsp;able&nbsp;to&nbsp;combine&nbsp;many&nbsp;images&nbsp;at&nbsp;different&nbsp;locations<br>
into&nbsp;one&nbsp;final&nbsp;image.<br>
The&nbsp;simplest&nbsp;merger&nbsp;is&nbsp;<a href="#LastMerger">LastMerger</a>,&nbsp;which&nbsp;doesn't&nbsp;do&nbsp;any&nbsp;extra&nbsp;processing,&nbsp;it<br>
simply&nbsp;places&nbsp;each&nbsp;image&nbsp;on&nbsp;top&nbsp;of&nbsp;each&nbsp;other,&nbsp;meaning&nbsp;overlapping&nbsp;areas&nbsp;will<br>
be&nbsp;the&nbsp;last&nbsp;image&nbsp;added.&nbsp;Other&nbsp;mergers&nbsp;attempt&nbsp;to&nbsp;combine&nbsp;images&nbsp;better&nbsp;but<br>
this&nbsp;requires&nbsp;using&nbsp;more&nbsp;memory&nbsp;and&nbsp;processing.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="Merger-add_image"><strong>add_image</strong></a>(self, image, location)</dt><dd><tt>Called&nbsp;to&nbsp;add&nbsp;an&nbsp;image.&nbsp;location&nbsp;is&nbsp;a&nbsp;tuple&nbsp;of&nbsp;slices&nbsp;used<br>
to&nbsp;select&nbsp;the&nbsp;area&nbsp;for&nbsp;the&nbsp;image,&nbsp;it&nbsp;is&nbsp;guaranteed&nbsp;to&nbsp;be&nbsp;the<br>
same&nbsp;size&nbsp;as&nbsp;image.</tt></dd></dl>

<dl><dt><a name="Merger-create_image"><strong>create_image</strong></a>(self, image_shape, image_dtype)</dt><dd><tt>Init&nbsp;is&nbsp;called&nbsp;with&nbsp;the&nbsp;shape&nbsp;of&nbsp;the&nbsp;final&nbsp;image&nbsp;(may&nbsp;be<br>
more&nbsp;than&nbsp;2d)&nbsp;and&nbsp;the&nbsp;dtype.&nbsp;Normally&nbsp;a&nbsp;merger&nbsp;would&nbsp;create<br>
an&nbsp;image&nbsp;using&nbsp;this&nbsp;information.</tt></dd></dl>

<dl><dt><a name="Merger-final_image"><strong>final_image</strong></a>(self)</dt><dd><tt>Called&nbsp;once&nbsp;to&nbsp;get&nbsp;the&nbsp;final&nbsp;image.&nbsp;It&nbsp;will&nbsp;only&nbsp;be&nbsp;called<br>
once&nbsp;when&nbsp;stitching,&nbsp;so&nbsp;final&nbsp;processing&nbsp;can&nbsp;take&nbsp;place&nbsp;and&nbsp;modify<br>
the&nbsp;stored&nbsp;image.&nbsp;Returns&nbsp;the&nbsp;final&nbsp;image&nbsp;and&nbsp;a&nbsp;mask&nbsp;for&nbsp;pixels&nbsp;that<br>
had&nbsp;no&nbsp;images.</tt></dd></dl>

<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="NearestMerger">class <strong>NearestMerger</strong></a>(<a href="constitch.merging.html#Merger">Merger</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>This&nbsp;merger&nbsp;keeps&nbsp;the&nbsp;pixel&nbsp;that&nbsp;is&nbsp;closer&nbsp;to&nbsp;the&nbsp;center&nbsp;of&nbsp;its&nbsp;image&nbsp;when&nbsp;there&nbsp;is&nbsp;overlap.<br>
This&nbsp;normally&nbsp;means&nbsp;that&nbsp;the&nbsp;edges&nbsp;of&nbsp;images&nbsp;are&nbsp;removed&nbsp;and&nbsp;central&nbsp;pixels&nbsp;are&nbsp;prioritized.<br>
This&nbsp;does&nbsp;require&nbsp;more&nbsp;memory,&nbsp;an&nbsp;extra&nbsp;array&nbsp;of&nbsp;uint16&nbsp;the&nbsp;size&nbsp;of&nbsp;the&nbsp;final&nbsp;image.&nbsp;If&nbsp;memory<br>
is&nbsp;an&nbsp;issue&nbsp;<a href="#EfficientNearestMerger">EfficientNearestMerger</a>&nbsp;uses&nbsp;a&nbsp;similar&nbsp;algorithm&nbsp;but&nbsp;only&nbsp;needs&nbsp;an&nbsp;array&nbsp;of&nbsp;uint8.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="constitch.merging.html#NearestMerger">NearestMerger</a></dd>
<dd><a href="constitch.merging.html#Merger">Merger</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="NearestMerger-add_image"><strong>add_image</strong></a>(self, image, location)</dt><dd><tt>Called&nbsp;to&nbsp;add&nbsp;an&nbsp;image.&nbsp;location&nbsp;is&nbsp;a&nbsp;tuple&nbsp;of&nbsp;slices&nbsp;used<br>
to&nbsp;select&nbsp;the&nbsp;area&nbsp;for&nbsp;the&nbsp;image,&nbsp;it&nbsp;is&nbsp;guaranteed&nbsp;to&nbsp;be&nbsp;the<br>
same&nbsp;size&nbsp;as&nbsp;image.</tt></dd></dl>

<dl><dt><a name="NearestMerger-create_image"><strong>create_image</strong></a>(self, image_shape, image_dtype)</dt><dd><tt>Init&nbsp;is&nbsp;called&nbsp;with&nbsp;the&nbsp;shape&nbsp;of&nbsp;the&nbsp;final&nbsp;image&nbsp;(may&nbsp;be<br>
more&nbsp;than&nbsp;2d)&nbsp;and&nbsp;the&nbsp;dtype.&nbsp;Normally&nbsp;a&nbsp;merger&nbsp;would&nbsp;create<br>
an&nbsp;image&nbsp;using&nbsp;this&nbsp;information.</tt></dd></dl>

<dl><dt><a name="NearestMerger-final_image"><strong>final_image</strong></a>(self)</dt><dd><tt>Called&nbsp;once&nbsp;to&nbsp;get&nbsp;the&nbsp;final&nbsp;image.&nbsp;It&nbsp;will&nbsp;only&nbsp;be&nbsp;called<br>
once&nbsp;when&nbsp;stitching,&nbsp;so&nbsp;final&nbsp;processing&nbsp;can&nbsp;take&nbsp;place&nbsp;and&nbsp;modify<br>
the&nbsp;stored&nbsp;image.&nbsp;Returns&nbsp;the&nbsp;final&nbsp;image&nbsp;and&nbsp;a&nbsp;mask&nbsp;for&nbsp;pixels&nbsp;that<br>
had&nbsp;no&nbsp;images.</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="constitch.merging.html#Merger">Merger</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="OptimalSolver">class <strong>OptimalSolver</strong></a>(<a href="constitch.solving.html#LinearSolver">LinearSolver</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#OptimalSolver">OptimalSolver</a>(model=None,&nbsp;loss_func=None)<br>
&nbsp;<br>
<a href="#Solver">Solver</a>&nbsp;that&nbsp;solves&nbsp;the&nbsp;system&nbsp;of&nbsp;equations&nbsp;generated&nbsp;by&nbsp;<a href="#LinearSolver">LinearSolver</a>&nbsp;by<br>
minimizing&nbsp;an&nbsp;arbitrary&nbsp;loss&nbsp;function.<br>
This&nbsp;solver&nbsp;uses&nbsp;the&nbsp;provided&nbsp;linear&nbsp;model,&nbsp;default&nbsp;LinearRegression,<br>
to&nbsp;get&nbsp;initial&nbsp;positions&nbsp;then&nbsp;uses&nbsp;scipy.optimize.minimize&nbsp;to&nbsp;find&nbsp;the&nbsp;final<br>
solution&nbsp;that&nbsp;minimizes&nbsp;the&nbsp;loss&nbsp;function.<br>
By&nbsp;default&nbsp;the&nbsp;loss&nbsp;function&nbsp;used&nbsp;is&nbsp;mean&nbsp;absolute&nbsp;error,&nbsp;however&nbsp;if&nbsp;you&nbsp;are<br>
looking&nbsp;to&nbsp;minimize&nbsp;on&nbsp;MAE&nbsp;you&nbsp;should&nbsp;use&nbsp;<a href="#MAESolver">MAESolver</a>&nbsp;as&nbsp;it&nbsp;is&nbsp;equivalent<br>
and&nbsp;more&nbsp;efficient.&nbsp;Only&nbsp;use&nbsp;this&nbsp;model&nbsp;when&nbsp;there&nbsp;is&nbsp;not&nbsp;a&nbsp;dedicated<br>
sklearn.linear_model&nbsp;or&nbsp;similar&nbsp;regressor&nbsp;that&nbsp;can&nbsp;be&nbsp;utilized&nbsp;with&nbsp;<a href="#LinearSolver">LinearSolver</a><br>
for&nbsp;your&nbsp;loss&nbsp;function<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="constitch.solving.html#OptimalSolver">OptimalSolver</a></dd>
<dd><a href="constitch.solving.html#LinearSolver">LinearSolver</a></dd>
<dd><a href="constitch.solving.html#Solver">Solver</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="OptimalSolver-__init__"><strong>__init__</strong></a>(self, model=None, loss_func=None)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="OptimalSolver-loss"><strong>loss</strong></a>(self, values, solution_mat, solution_vals)</dt></dl>

<dl><dt><a name="OptimalSolver-solve_matrix"><strong>solve_matrix</strong></a>(self, solution_mat, solution_vals, initial_values)</dt></dl>

<hr>
Methods inherited from <a href="constitch.solving.html#LinearSolver">LinearSolver</a>:<br>
<dl><dt><a name="OptimalSolver-make_constraint_matrix"><strong>make_constraint_matrix</strong></a>(self, constraints, initial_poses)</dt></dl>

<dl><dt><a name="OptimalSolver-make_positions"><strong>make_positions</strong></a>(self, initial_poses, poses)</dt></dl>

<dl><dt><a name="OptimalSolver-score_func"><strong>score_func</strong></a>(self, constraint)</dt></dl>

<dl><dt><a name="OptimalSolver-solve"><strong>solve</strong></a>(self, constraints, initial_poses)</dt><dd><tt>Solve&nbsp;the&nbsp;global&nbsp;positions&nbsp;for&nbsp;images&nbsp;given&nbsp;the&nbsp;constraints&nbsp;and&nbsp;estimated&nbsp;positions.<br>
returns&nbsp;the&nbsp;xy&nbsp;position&nbsp;for&nbsp;each&nbsp;image,&nbsp;mapping&nbsp;the&nbsp;image&nbsp;index&nbsp;to&nbsp;the&nbsp;position<br>
with&nbsp;a&nbsp;dictionary.<br>
Additionally&nbsp;the&nbsp;constraints&nbsp;dictionary&nbsp;can&nbsp;be&nbsp;returned&nbsp;as&nbsp;the&nbsp;second&nbsp;return&nbsp;value,&nbsp;which<br>
will&nbsp;replace&nbsp;the&nbsp;constraints&nbsp;in&nbsp;the&nbsp;composite&nbsp;with&nbsp;the&nbsp;ones&nbsp;returned,&nbsp;filtering&nbsp;outliers.</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="constitch.solving.html#Solver">Solver</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="OutlierSolver">class <strong>OutlierSolver</strong></a>(<a href="constitch.solving.html#Solver">Solver</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#OutlierSolver">OutlierSolver</a>(solver=None,&nbsp;outlier_threshold=1.5)<br>
&nbsp;<br>
<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="constitch.solving.html#OutlierSolver">OutlierSolver</a></dd>
<dd><a href="constitch.solving.html#Solver">Solver</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="OutlierSolver-__init__"><strong>__init__</strong></a>(self, solver=None, outlier_threshold=1.5)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="OutlierSolver-solve"><strong>solve</strong></a>(self, constraints, initial_poses)</dt><dd><tt>Solve&nbsp;the&nbsp;global&nbsp;positions&nbsp;for&nbsp;images&nbsp;given&nbsp;the&nbsp;constraints&nbsp;and&nbsp;estimated&nbsp;positions.<br>
returns&nbsp;the&nbsp;xy&nbsp;position&nbsp;for&nbsp;each&nbsp;image,&nbsp;mapping&nbsp;the&nbsp;image&nbsp;index&nbsp;to&nbsp;the&nbsp;position<br>
with&nbsp;a&nbsp;dictionary.<br>
Additionally&nbsp;the&nbsp;constraints&nbsp;dictionary&nbsp;can&nbsp;be&nbsp;returned&nbsp;as&nbsp;the&nbsp;second&nbsp;return&nbsp;value,&nbsp;which<br>
will&nbsp;replace&nbsp;the&nbsp;constraints&nbsp;in&nbsp;the&nbsp;composite&nbsp;with&nbsp;the&nbsp;ones&nbsp;returned,&nbsp;filtering&nbsp;outliers.</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="constitch.solving.html#Solver">Solver</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="PCCAligner">class <strong>PCCAligner</strong></a>(<a href="constitch.alignment.html#Aligner">Aligner</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#PCCAligner">PCCAligner</a>(**kwargs)<br>
&nbsp;<br>
An&nbsp;aligner&nbsp;that&nbsp;invokes&nbsp;the&nbsp;skimage.registration.phase_cross_correlation&nbsp;method<br>
An&nbsp;alternative&nbsp;to&nbsp;the&nbsp;<a href="#FFTAligner">FFTAligner</a>&nbsp;which&nbsp;implements&nbsp;the&nbsp;same&nbsp;algorithm<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="constitch.alignment.html#PCCAligner">PCCAligner</a></dd>
<dd><a href="constitch.alignment.html#Aligner">Aligner</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="PCCAligner-__init__"><strong>__init__</strong></a>(self, **kwargs)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="PCCAligner-align"><strong>align</strong></a>(self, constraint, precalc1=None, precalc2=None)</dt><dd><tt>Performs&nbsp;the&nbsp;alignment&nbsp;of&nbsp;two&nbsp;images,&nbsp;finding&nbsp;the&nbsp;pixel&nbsp;offset&nbsp;that&nbsp;best&nbsp;aligns&nbsp;the<br>
two&nbsp;images.&nbsp;The&nbsp;offset&nbsp;should&nbsp;be&nbsp;from&nbsp;image1&nbsp;to&nbsp;image2.&nbsp;The&nbsp;return&nbsp;value&nbsp;should&nbsp;be&nbsp;a&nbsp;<a href="#Constraint">Constraint</a><br>
<a href="builtins.html#object">object</a>,&nbsp;with&nbsp;at&nbsp;least&nbsp;the&nbsp;dx,&nbsp;dy&nbsp;fields&nbsp;filled&nbsp;in&nbsp;to&nbsp;represent&nbsp;the&nbsp;offset&nbsp;of&nbsp;image2&nbsp;needed<br>
to&nbsp;align&nbsp;the&nbsp;two&nbsp;images.&nbsp;If&nbsp;the&nbsp;function&nbsp;finds&nbsp;the&nbsp;images&nbsp;don't&nbsp;overlap,&nbsp;None&nbsp;should&nbsp;be&nbsp;returned.<br>
If&nbsp;a&nbsp;constraint&nbsp;is&nbsp;specified,&nbsp;this&nbsp;method&nbsp;should&nbsp;only&nbsp;return&nbsp;a&nbsp;constraint&nbsp;that&nbsp;fits&nbsp;within&nbsp;the&nbsp;error<br>
of&nbsp;given&nbsp;constraint,&nbsp;meaning&nbsp;within&nbsp;constraint.error&nbsp;pixels&nbsp;from&nbsp;the&nbsp;(constraint.dx,&nbsp;constraint.dy)<br>
offset.</tt></dd></dl>

<hr>
Methods inherited from <a href="constitch.alignment.html#Aligner">Aligner</a>:<br>
<dl><dt><a name="PCCAligner-precalculate"><strong>precalculate</strong></a>(self, image, box)</dt><dd><tt>Performs&nbsp;an&nbsp;arbitrary&nbsp;precalculation&nbsp;step&nbsp;specific&nbsp;to&nbsp;the&nbsp;alignment&nbsp;algorithm.<br>
This&nbsp;would&nbsp;be&nbsp;a&nbsp;step&nbsp;in&nbsp;the&nbsp;algorithm&nbsp;that&nbsp;only&nbsp;has&nbsp;to&nbsp;be&nbsp;run&nbsp;once&nbsp;per&nbsp;image,<br>
and&nbsp;can&nbsp;be&nbsp;cached&nbsp;for&nbsp;each&nbsp;calculation&nbsp;done&nbsp;with&nbsp;the&nbsp;same&nbsp;image.&nbsp;The&nbsp;result&nbsp;of<br>
this&nbsp;function&nbsp;will&nbsp;be&nbsp;passed&nbsp;to&nbsp;the&nbsp;align&nbsp;function&nbsp;as&nbsp;the&nbsp;precalc1&nbsp;or&nbsp;precalc2&nbsp;argument</tt></dd></dl>

<dl><dt><a name="PCCAligner-precalculate_if_needed"><strong>precalculate_if_needed</strong></a>(self, constraint, precalc1, precalc2)</dt></dl>

<dl><dt><a name="PCCAligner-resize_if_needed"><strong>resize_if_needed</strong></a>(self, image, box=None, downscale_factor=None, padding=None)</dt><dd><tt>#&nbsp;Helper&nbsp;functions&nbsp;for&nbsp;subclasses:</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="constitch.alignment.html#Aligner">Aligner</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="SimpleOffsetModel">class <strong>SimpleOffsetModel</strong></a>(<a href="constitch.stage_model.html#ConversionStageModel">ConversionStageModel</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#SimpleOffsetModel">SimpleOffsetModel</a>(model=None)<br>
&nbsp;<br>
Simple&nbsp;stage&nbsp;model&nbsp;that&nbsp;calculates&nbsp;the&nbsp;offsets&nbsp;of&nbsp;the&nbsp;two<br>
images&nbsp;and&nbsp;gives&nbsp;them&nbsp;to&nbsp;the&nbsp;internal&nbsp;model&nbsp;(default&nbsp;LinearRegression)<br>
for&nbsp;estimation.<br>
&nbsp;<br>
This&nbsp;model&nbsp;is&nbsp;the&nbsp;most&nbsp;simple,&nbsp;it&nbsp;only&nbsp;considers&nbsp;the&nbsp;relative&nbsp;positions&nbsp;of<br>
the&nbsp;two&nbsp;images<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="constitch.stage_model.html#SimpleOffsetModel">SimpleOffsetModel</a></dd>
<dd><a href="constitch.stage_model.html#ConversionStageModel">ConversionStageModel</a></dd>
<dd><a href="sklearn.base.html#BaseEstimator">sklearn.base.BaseEstimator</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="SimpleOffsetModel-conversion_func"><strong>conversion_func</strong></a>(self, poses1, poses2)</dt></dl>

<hr>
Methods inherited from <a href="constitch.stage_model.html#ConversionStageModel">ConversionStageModel</a>:<br>
<dl><dt><a name="SimpleOffsetModel-__init__"><strong>__init__</strong></a>(self, model=None)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="SimpleOffsetModel-__repr__"><strong>__repr__</strong></a>(self)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="SimpleOffsetModel-__str__"><strong>__str__</strong></a>(self)</dt><dd><tt>Return&nbsp;str(self).</tt></dd></dl>

<dl><dt><a name="SimpleOffsetModel-fit"><strong>fit</strong></a>(self, X, y)</dt></dl>

<dl><dt><a name="SimpleOffsetModel-fit_predict"><strong>fit_predict</strong></a>(self, X, y)</dt></dl>

<dl><dt><a name="SimpleOffsetModel-predict"><strong>predict</strong></a>(self, X)</dt></dl>

<dl><dt><a name="SimpleOffsetModel-score"><strong>score</strong></a>(self, X, y)</dt></dl>

<dl><dt><a name="SimpleOffsetModel-split_X"><strong>split_X</strong></a>(self, X)</dt></dl>

<hr>
Methods inherited from <a href="sklearn.base.html#BaseEstimator">sklearn.base.BaseEstimator</a>:<br>
<dl><dt><a name="SimpleOffsetModel-__getstate__"><strong>__getstate__</strong></a>(self)</dt></dl>

<dl><dt><a name="SimpleOffsetModel-__setstate__"><strong>__setstate__</strong></a>(self, state)</dt></dl>

<dl><dt><a name="SimpleOffsetModel-get_params"><strong>get_params</strong></a>(self, deep=True)</dt><dd><tt>Get&nbsp;parameters&nbsp;for&nbsp;this&nbsp;estimator.<br>
&nbsp;<br>
Parameters<br>
----------<br>
deep&nbsp;:&nbsp;bool,&nbsp;default=True<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True,&nbsp;will&nbsp;return&nbsp;the&nbsp;parameters&nbsp;for&nbsp;this&nbsp;estimator&nbsp;and<br>
&nbsp;&nbsp;&nbsp;&nbsp;contained&nbsp;subobjects&nbsp;that&nbsp;are&nbsp;estimators.<br>
&nbsp;<br>
Returns<br>
-------<br>
params&nbsp;:&nbsp;dict<br>
&nbsp;&nbsp;&nbsp;&nbsp;Parameter&nbsp;names&nbsp;mapped&nbsp;to&nbsp;their&nbsp;values.</tt></dd></dl>

<dl><dt><a name="SimpleOffsetModel-set_params"><strong>set_params</strong></a>(self, **params)</dt><dd><tt>Set&nbsp;the&nbsp;parameters&nbsp;of&nbsp;this&nbsp;estimator.<br>
&nbsp;<br>
The&nbsp;method&nbsp;works&nbsp;on&nbsp;simple&nbsp;estimators&nbsp;as&nbsp;well&nbsp;as&nbsp;on&nbsp;nested&nbsp;objects<br>
(such&nbsp;as&nbsp;:class:`~sklearn.pipeline.Pipeline`).&nbsp;The&nbsp;latter&nbsp;have<br>
parameters&nbsp;of&nbsp;the&nbsp;form&nbsp;``&lt;component&gt;__&lt;parameter&gt;``&nbsp;so&nbsp;that&nbsp;it's<br>
possible&nbsp;to&nbsp;update&nbsp;each&nbsp;component&nbsp;of&nbsp;a&nbsp;nested&nbsp;<a href="builtins.html#object">object</a>.<br>
&nbsp;<br>
Parameters<br>
----------<br>
**params&nbsp;:&nbsp;dict<br>
&nbsp;&nbsp;&nbsp;&nbsp;Estimator&nbsp;parameters.<br>
&nbsp;<br>
Returns<br>
-------<br>
self&nbsp;:&nbsp;estimator&nbsp;instance<br>
&nbsp;&nbsp;&nbsp;&nbsp;Estimator&nbsp;instance.</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="sklearn.base.html#BaseEstimator">sklearn.base.BaseEstimator</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Solver">class <strong>Solver</strong></a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Base&nbsp;class&nbsp;that&nbsp;takes&nbsp;in&nbsp;all&nbsp;the&nbsp;constraints&nbsp;of&nbsp;a&nbsp;composite<br>
and&nbsp;solves&nbsp;them&nbsp;into&nbsp;global&nbsp;positions<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="Solver-solve"><strong>solve</strong></a>(self, constraints, initial_poses)</dt><dd><tt>Solve&nbsp;the&nbsp;global&nbsp;positions&nbsp;for&nbsp;images&nbsp;given&nbsp;the&nbsp;constraints&nbsp;and&nbsp;estimated&nbsp;positions.<br>
returns&nbsp;the&nbsp;xy&nbsp;position&nbsp;for&nbsp;each&nbsp;image,&nbsp;mapping&nbsp;the&nbsp;image&nbsp;index&nbsp;to&nbsp;the&nbsp;position<br>
with&nbsp;a&nbsp;dictionary.<br>
Additionally&nbsp;the&nbsp;constraints&nbsp;dictionary&nbsp;can&nbsp;be&nbsp;returned&nbsp;as&nbsp;the&nbsp;second&nbsp;return&nbsp;value,&nbsp;which<br>
will&nbsp;replace&nbsp;the&nbsp;constraints&nbsp;in&nbsp;the&nbsp;composite&nbsp;with&nbsp;the&nbsp;ones&nbsp;returned,&nbsp;filtering&nbsp;outliers.</tt></dd></dl>

<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="SpanningTreeSolver">class <strong>SpanningTreeSolver</strong></a>(<a href="constitch.solving.html#Solver">Solver</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Solver">Solver</a>&nbsp;that&nbsp;finds&nbsp;the&nbsp;maximum&nbsp;spanning&nbsp;tree,&nbsp;and&nbsp;uses&nbsp;it&nbsp;to&nbsp;solve&nbsp;for<br>
global&nbsp;positions&nbsp;of&nbsp;all&nbsp;images<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="constitch.solving.html#SpanningTreeSolver">SpanningTreeSolver</a></dd>
<dd><a href="constitch.solving.html#Solver">Solver</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="SpanningTreeSolver-__init__"><strong>__init__</strong></a>(self)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="SpanningTreeSolver-solve"><strong>solve</strong></a>(self, constraints, initial_poses)</dt><dd><tt>Constructs&nbsp;a&nbsp;maximum&nbsp;spanning&nbsp;tree&nbsp;with&nbsp;Kruskals&nbsp;algorithm</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="constitch.solving.html#Solver">Solver</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table></td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#eeaa77">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Functions</strong></big></font></td></tr>
    
<tr><td bgcolor="#eeaa77"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><dl><dt><a name="-load"><strong>load</strong></a>(path, composite=None, constraints=True, images_file=None, **kwargs)</dt><dd><tt>Loads&nbsp;a&nbsp;<a href="#CompositeImage">CompositeImage</a>&nbsp;instance&nbsp;and&nbsp;any&nbsp;additional&nbsp;CompositeSet&nbsp;instances<br>
saved&nbsp;to&nbsp;a&nbsp;json&nbsp;file&nbsp;with&nbsp;<a href="#-load">load</a>()<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;path&nbsp;(str&nbsp;or&nbsp;io.IOBase):&nbsp;The&nbsp;path&nbsp;or&nbsp;file&nbsp;<a href="builtins.html#object">object</a>&nbsp;to&nbsp;read&nbsp;the&nbsp;json&nbsp;from<br>
&nbsp;&nbsp;&nbsp;&nbsp;constraints&nbsp;(bool,&nbsp;default&nbsp;True):&nbsp;Whether&nbsp;to&nbsp;load&nbsp;any&nbsp;<a href="#ConstraintSet">ConstraintSet</a>&nbsp;instances<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;False,&nbsp;any&nbsp;constraint&nbsp;sets&nbsp;saved&nbsp;in&nbsp;the&nbsp;file&nbsp;are&nbsp;ignored<br>
&nbsp;&nbsp;&nbsp;&nbsp;images_file&nbsp;(str&nbsp;or&nbsp;io.IOBase):&nbsp;path&nbsp;or&nbsp;file&nbsp;<a href="builtins.html#object">object</a>&nbsp;to&nbsp;load&nbsp;images&nbsp;from<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Where&nbsp;images&nbsp;will&nbsp;be&nbsp;read&nbsp;from,&nbsp;using&nbsp;tifffile.imread<br>
&nbsp;&nbsp;&nbsp;&nbsp;**kwargs:&nbsp;Extra&nbsp;arguments&nbsp;that&nbsp;are&nbsp;passed&nbsp;to&nbsp;<a href="#CompositeImage">CompositeImage</a>()<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;composite&nbsp;(<a href="#CompositeImage">CompositeImage</a>):&nbsp;The&nbsp;composite&nbsp;read&nbsp;from&nbsp;the&nbsp;file<br>
&nbsp;&nbsp;&nbsp;&nbsp;*constraints&nbsp;(<a href="#ConstraintSet">ConstraintSet</a>):&nbsp;Any&nbsp;<a href="#ConstraintSet">ConstraintSet</a>&nbsp;instances&nbsp;that<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;were&nbsp;saved&nbsp;with&nbsp;the&nbsp;composite.</tt></dd></dl>
 <dl><dt><a name="-save"><strong>save</strong></a>(path, composite, *constraint_sets, save_images=False, images_file=None)</dt><dd><tt>Saves&nbsp;a&nbsp;<a href="#CompositeImage">CompositeImage</a>&nbsp;and&nbsp;any&nbsp;number&nbsp;of&nbsp;<a href="#ConstraintSet">ConstraintSet</a>&nbsp;instances<br>
containing&nbsp;constraints&nbsp;from&nbsp;the&nbsp;composite&nbsp;to&nbsp;a&nbsp;json&nbsp;file.&nbsp;All&nbsp;objects&nbsp;passed&nbsp;to&nbsp;this&nbsp;method<br>
can&nbsp;be&nbsp;restored&nbsp;with&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#-load">load</a>()<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;path&nbsp;(str&nbsp;or&nbsp;io.IOBase):&nbsp;The&nbsp;path&nbsp;or&nbsp;file&nbsp;<a href="builtins.html#object">object</a>&nbsp;to&nbsp;save&nbsp;to<br>
&nbsp;&nbsp;&nbsp;&nbsp;composite&nbsp;(<a href="#CompositeImage">CompositeImage</a>):&nbsp;The&nbsp;composite&nbsp;to&nbsp;be&nbsp;saved<br>
&nbsp;&nbsp;&nbsp;&nbsp;*constraint_sets&nbsp;(<a href="#ConstraintSet">ConstraintSet</a>):&nbsp;Any&nbsp;ConstraintSets&nbsp;to&nbsp;be&nbsp;saved&nbsp;along&nbsp;with&nbsp;the&nbsp;composite.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;These&nbsp;sets&nbsp;must&nbsp;contain&nbsp;constraints&nbsp;from&nbsp;the&nbsp;passed&nbsp;in&nbsp;composite.<br>
&nbsp;&nbsp;&nbsp;&nbsp;save_images&nbsp;(bool):&nbsp;If&nbsp;True,&nbsp;or&nbsp;if&nbsp;images_file&nbsp;is&nbsp;specified,&nbsp;the&nbsp;images&nbsp;in&nbsp;the&nbsp;composite&nbsp;are&nbsp;saved&nbsp;using&nbsp;tifffile.imwrite<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to&nbsp;the&nbsp;path&nbsp;or&nbsp;file&nbsp;<a href="builtins.html#object">object</a>&nbsp;images_file<br>
&nbsp;&nbsp;&nbsp;&nbsp;images_file&nbsp;(str&nbsp;or&nbsp;io.IOBase):&nbsp;The&nbsp;path&nbsp;or&nbsp;file&nbsp;<a href="builtins.html#object">object</a>&nbsp;to&nbsp;save&nbsp;the&nbsp;composite&nbsp;images&nbsp;to<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This&nbsp;defaults&nbsp;to&nbsp;path&nbsp;+&nbsp;'.tif'.</tt></dd></dl>
</td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#55aa55">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Data</strong></big></font></td></tr>
    
<tr><td bgcolor="#55aa55"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><strong>__all__</strong> = ['composite', 'constraints', 'alignment', 'stitching', 'evaluation', 'merging', 'CompositeImage', 'BBox', 'BBoxList', 'Constraint', 'ConstraintSet', 'ConstraintFilter', 'Aligner', 'FFTAligner', 'PCCAligner', 'FeatureAligner', 'Merger', 'MeanMerger', 'EfficientMeanMerger', 'NearestMerger', ...]</td></tr></table>
</body></html>